This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
public/file.svg
public/globe.svg
public/next.svg
public/vercel.svg
public/window.svg
README.md
src/app/api/analysis/[id]/route.ts
src/app/api/analyze-rfp/parse-pdf/route.ts
src/app/api/analyze-rfp/route.ts
src/app/api/parse-docx/route.ts
src/app/api/parse-pdf/route.ts
src/app/components/dashboard/RecommendationsList.tsx
src/app/components/dashboard/SectionAnalysis.tsx
src/app/components/dashboard/SectionDetail.tsx
src/app/components/forms/UploadForm.tsx
src/app/components/layout/Navbar.tsx
src/app/components/layout/Sidebar.tsx
src/app/components/results/ExecutiveSummary.tsx
src/app/globals.css
src/app/layout.tsx
src/app/lib/analyzers/baseAnalyzer.ts
src/app/lib/analyzers/certificationsAnalyzer.ts
src/app/lib/analyzers/contractDataAnalyzer.ts
src/app/lib/analyzers/contractTermsAnalyzer.ts
src/app/lib/analyzers/cybersecurityAnalyzer.ts
src/app/lib/analyzers/environmentalAnalyzer.ts
src/app/lib/analyzers/evaluationCriteriaAnalyzer.ts
src/app/lib/analyzers/index.ts
src/app/lib/analyzers/introductionAnalyzer.ts
src/app/lib/analyzers/keyPersonnelAnalyzer.ts
src/app/lib/analyzers/managementApproachAnalyzer.ts
src/app/lib/analyzers/pastPerformanceAnalyzer.ts
src/app/lib/analyzers/periodOfPerformanceAnalyzer.ts
src/app/lib/analyzers/priceCostProposalAnalyzer.ts
src/app/lib/analyzers/proposalSubmissionAnalyzer.ts
src/app/lib/analyzers/riskAssessmentAnalyzer.ts
src/app/lib/analyzers/sowAnalyzer.ts
src/app/lib/analyzers/subcontractingPlanAnalyzer.ts
src/app/lib/analyzers/supplyChainRiskAnalyzer.ts
src/app/lib/analyzers/technicalApproachAnalyzer.ts
src/app/lib/fileProcessor.ts
src/app/lib/rfpAnalyzer.ts
src/app/lib/stores/analysisStore.ts
src/app/page.tsx
src/app/results/[id]/page.tsx
src/app/types.ts
src/app/types/index.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "docx": "^9.3.0",
    "mammoth": "^1.9.0",
    "next": "15.2.3",
    "pdf-parse": "^1.1.1",
    "pdfjs-dist": "^5.2.133",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "uuid": "^11.1.0",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/pdf-parse": "^1.1.4",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.2.3",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="src/app/api/analysis/[id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';

// This is a mock implementation - in a real app, you would fetch from a database
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const id = params.id;
  
  // In a real implementation, you would fetch from a database
  // For this example, we'll return mock data
  
  // Check if id exists (mock)
  if (!id.startsWith('analysis-')) {
    return NextResponse.json({ error: 'Analysis not found' }, { status: 404 });
  }
  
  // Mock data - this would come from a database in a real app
  const results = {
    introduction: {
      sectionName: 'Introduction',
      extractedInformation: {
        purpose: 'The purpose of this solicitation is to procure IT services...',
        background: 'The agency has been operating...',
        requirements: 'Vendors must comply with all regulations...'
      },
      evaluationResults: [
        {
          criterion: 'Purpose Clarity',
          score: 4,
          maxScore: 5,
          comments: 'Clear purpose statement provided.'
        },
        // Additional criteria evaluations
      ],
      evaluationScore: 4.0,
      recommendations: [
        {
          priority: 'medium',
          title: 'Enhance Requirements Compliance',
          description: 'Add specific references to applicable regulations.'
        }
      ]
    },
    // Other sections would be included here
    executiveSummary: {
      overallScore: 3.7,
      sectionScores: {
        introduction: 4.0,
        sow: 3.5,
        // Other section scores
      },
      strongSections: [
        { section: 'introduction', score: 4.0 },
        { section: 'evaluationCriteria', score: 3.9 },
        { section: 'keyPersonnel', score: 3.8 }
      ],
      weakSections: [
        { section: 'supplyChainRisk', score: 2.1 },
        { section: 'environmentalConsiderations', score: 2.4 },
        { section: 'subcontractingPlan', score: 2.8 }
      ],
      missingRequiredSections: []
    },
    recommendations: {
      highPriority: [
        {
          priority: 'high',
          title: 'Develop Supply Chain Risk Framework',
          description: 'Implement comprehensive risk assessment methodology.'
        },
        {
          priority: 'high',
          title: 'Enhance Environmental Requirements',
          description: 'Add specific environmental compliance certification requirements.'
        }
      ],
      mediumPriority: [
        {
          priority: 'medium',
          title: 'Strengthen Subcontracting Plan Requirements',
          description: 'Establish specific small business subcontracting targets.'
        }
      ],
      lowPriority: [],
      processImprovements: [
        {
          priority: 'medium',
          title: 'Standardize RFP Template',
          description: 'Implement a standardized template incorporating all 18 essential sections.'
        }
      ]
    }
  };
  
  return NextResponse.json({ id, results });
}
</file>

<file path="src/app/api/analyze-rfp/parse-pdf/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { promises as fs } from 'fs';
import path from 'path';
import os from 'os';
import { v4 as uuidv4 } from 'uuid';
import pdfParse from 'pdf-parse';

// This would require the pdf-parse package to be installed
// npm install pdf-parse

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get('file') as File;
    
    if (!file) {
      return NextResponse.json(
        { error: 'No file provided' },
        { status: 400 }
      );
    }
    
    // Create a temporary file to store the uploaded PDF
    const tempDir = os.tmpdir();
    const tempFilePath = path.join(tempDir, `${uuidv4()}.pdf`);
    
    // Write the file to disk
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);
    await fs.writeFile(tempFilePath, buffer);
    
    // Process the PDF using pdf-parse
    const dataBuffer = await fs.readFile(tempFilePath);
    const data = await pdfParse(dataBuffer);
    const text = data.text;
    
    // Clean up the temporary file
    await fs.unlink(tempFilePath);
    
    return NextResponse.json({ text });
  } catch (error) {
    console.error('Error processing PDF:', error);
    return NextResponse.json(
      { error: 'Failed to process PDF file' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/analyze-rfp/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { RFPAnalyzer } from '@/app/lib/rfpAnalyzer';
import { RFPDocument } from '@/app/types';

export async function POST(request: NextRequest) {
  try {
    const data = await request.json();
    const { document } = data as { document: RFPDocument };
    
    if (!document) {
      return NextResponse.json(
        { error: 'No RFP document provided' },
        { status: 400 }
      );
    }
    
    const analyzer = new RFPAnalyzer();
    const results = analyzer.analyzeRFP(document);
    
    // In a real implementation, you might save the results to a database
    // and return an ID for later retrieval
    
    return NextResponse.json({ 
      success: true,
      results,
      id: 'analysis-' + Date.now() // Placeholder ID
    });
  } catch (error) {
    console.error('Error analyzing RFP:', error);
    return NextResponse.json(
      { error: 'Failed to analyze RFP document' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/parse-docx/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import mammoth from 'mammoth';

// This would require the mammoth package to be installed
// npm install mammoth

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get('file') as File;
    
    if (!file) {
      return NextResponse.json(
        { error: 'No file provided' },
        { status: 400 }
      );
    }
    
    // Convert File to Buffer
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);
    
    // Parse DOCX
    const result = await mammoth.extractRawText({ buffer });
    const text = result.value;
    
    return NextResponse.json({ text });
  } catch (error) {
    console.error('Error processing DOCX:', error);
    return NextResponse.json(
      { error: 'Failed to process DOCX file' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/parse-pdf/route.ts">
import { NextRequest, NextResponse } from 'next/server';
// Attempt direct import, relying on types package
import { getDocument, GlobalWorkerOptions } from 'pdfjs-dist';
import type { TextItem, PDFDocumentProxy } from 'pdfjs-dist/types/src/display/api';

// Set worker source - using require might help in some environments
GlobalWorkerOptions.workerSrc = require.resolve('pdfjs-dist/build/pdf.worker.js');

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get('file') as File | null;

    if (!file) {
      return NextResponse.json({ error: 'No file uploaded' }, { status: 400 });
    }

    const fileBuffer = await file.arrayBuffer();

    const loadingTask = getDocument({ data: fileBuffer });
    const pdfDocument: PDFDocumentProxy = await loadingTask.promise;

    let fullText = '';
    for (let i = 1; i <= pdfDocument.numPages; i++) {
      const page = await pdfDocument.getPage(i);
      const textContent = await page.getTextContent();
      
      // Type guard remains useful
      const isTextItem = (item: unknown): item is TextItem => 
        !!item && typeof item === 'object' && 'str' in item && typeof (item as { str: string }).str === 'string';

      const pageText = textContent.items
                       .filter(isTextItem)
                       .map((item: TextItem) => item.str)
                       .join(' ');
      fullText += pageText + '\n';
    }

    return NextResponse.json({ text: fullText.trim() });

  } catch (error) {
    console.error('Error parsing PDF with pdfjs-dist:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error during PDF parsing';
    return NextResponse.json(
      { error: `Failed to parse PDF: ${errorMessage}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/components/dashboard/RecommendationsList.tsx">
interface Recommendation {
  priority: 'high' | 'medium' | 'low';
  section: string;
  recommendation: string;
}

interface RecommendationsListProps {
  recommendations: Recommendation[];
}

export default function RecommendationsList({ recommendations }: RecommendationsListProps) {
  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'high':
        return 'bg-red-100 text-red-800 border-red-300';
      case 'medium':
        return 'bg-yellow-100 text-yellow-800 border-yellow-300';
      case 'low':
        return 'bg-green-100 text-green-800 border-green-300';
      default:
        return 'bg-gray-100 text-gray-800 border-gray-300';
    }
  };
  
  const getPriorityIcon = (priority: string) => {
    switch (priority) {
      case 'high':
        return '‚ö†Ô∏è';
      case 'medium':
        return '‚ö°';
      case 'low':
        return 'üí°';
      default:
        return 'üìù';
    }
  };
  
  return (
    <div className="bg-white rounded-lg shadow-md p-4">
      {recommendations.length === 0 ? (
        <p className="text-gray-500 text-center py-4">
          No recommendations available.
        </p>
      ) : (
        <ul className="space-y-4">
          {recommendations.map((rec, index) => (
            <li
              key={index}
              className={`p-4 rounded-md border ${getPriorityColor(rec.priority)}`}
            >
              <div className="flex items-start">
                <span className="text-2xl mr-3" role="img" aria-label={`${rec.priority} priority`}>
                  {getPriorityIcon(rec.priority)}
                </span>
                <div>
                  <h4 className="font-medium mb-1">
                    {rec.section}
                  </h4>
                  <p className="text-sm">
                    {rec.recommendation}
                  </p>
                  <span className="inline-block mt-2 text-xs font-medium uppercase">
                    {rec.priority} Priority
                  </span>
                </div>
              </div>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
</file>

<file path="src/app/components/dashboard/SectionAnalysis.tsx">
import { useState } from 'react';
import SectionDetail from '@/app/components/dashboard/SectionDetail';
import { AnalysisResults, SectionAnalysisResult } from '@/app/types';

type SectionAnalysisProps = {
  analysisResults: AnalysisResults;
};

export default function SectionAnalysis({ analysisResults }: SectionAnalysisProps) {
  const [selectedSection, setSelectedSection] = useState<string | null>(null);
  
  // Filter out non-section keys from results
  const sectionKeys = Object.keys(analysisResults).filter(key => 
    key !== 'executiveSummary' && key !== 'recommendations'
  );
  
  const getScoreColor = (score: number) => {
    if (score >= 4) return 'bg-green-100 border-green-500 text-green-700';
    if (score >= 3) return 'bg-yellow-100 border-yellow-500 text-yellow-700';
    return 'bg-red-100 border-red-500 text-red-700';
  };
  
  const getSectionStatus = (section: SectionAnalysisResult | { status: string; message: string }) => {
    if ('status' in section && section.status === 'Not Found') {
      return (
        <span className="inline-block px-2 py-1 bg-gray-100 text-gray-700 rounded text-xs">
          Not Found
        </span>
      );
    }
    
    const analysisResult = section as SectionAnalysisResult;
    return (
      <span className={`inline-block px-2 py-1 rounded text-xs ${getScoreColor(analysisResult.evaluationScore)}`}>
        {analysisResult.evaluationScore}/5.0
      </span>
    );
  };

  return (
    <div className="bg-white p-6 rounded-lg shadow-md">
      <div className="mb-8">
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
          {sectionKeys.map((sectionKey) => {
            const section = analysisResults[sectionKey];
            return (
              <div
                key={sectionKey}
                className={`p-4 border rounded-md cursor-pointer transition hover:shadow-md ${
                  selectedSection === sectionKey 
                    ? 'border-blue-500 bg-blue-50' 
                    : 'border-gray-200'
                }`}
                onClick={() => setSelectedSection(sectionKey)}
              >
                <div className="flex justify-between items-center mb-2">
                  <h4 className="font-medium">
                    {('sectionName' in section ? section.sectionName : sectionKey)}
                  </h4>
                  {getSectionStatus(section as SectionAnalysisResult | { status: string; message: string })}
                </div>
                
                {('status' in section && section.status !== 'Not Found' && 'recommendations' in section && 'evaluationScore' in section && Array.isArray(section.recommendations)) && (
                  <div className="mt-2 text-sm">
                    <span className="text-gray-600">
                      {section.recommendations.length} recommendation{section.recommendations.length !== 1 ? 's' : ''}
                    </span>
                  </div>
                )}
              </div>
            );
          })}
        </div>
      </div>
      
      {selectedSection && analysisResults[selectedSection] && 
       !('status' in analysisResults[selectedSection] && analysisResults[selectedSection].status === 'Not Found') && (
        <SectionDetail 
          section={analysisResults[selectedSection] as SectionAnalysisResult} 
          sectionName={selectedSection}
        />
      )}
      
      {selectedSection && analysisResults[selectedSection] && 
       ('status' in analysisResults[selectedSection] && analysisResults[selectedSection].status === 'Not Found') && (
        <div className="p-4 border border-gray-200 rounded-md bg-gray-50">
          <h3 className="text-lg font-semibold mb-2">
            {selectedSection} Section
          </h3>
          <p className="text-gray-600">
            {(analysisResults[selectedSection] as { message: string }).message}
          </p>
          <div className="mt-4">
            <h4 className="font-medium mb-2">Recommendation</h4>
            <p className="text-gray-700">
              Include this section in your RFP document to improve completeness and compliance.
            </p>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/components/dashboard/SectionDetail.tsx">
import { SectionAnalysisResult } from '@/app/types';

type SectionDetailProps = {
  section: SectionAnalysisResult;
  sectionName: string;
};

export default function SectionDetail({ section, sectionName }: SectionDetailProps) {
  const getScoreIndicator = (score: number) => {
    if (score >= 4) return 'üü¢';
    if (score >= 3) return 'üü°';
    return 'üî¥';
  };

  return (
    <div className="border border-gray-200 rounded-md p-4">
      <h3 className="text-xl font-semibold mb-4">
        {section.sectionName || sectionName} Analysis
      </h3>
      
      <div className="mb-6">
        <h4 className="font-medium mb-2">Extracted Information</h4>
        <div className="space-y-3">
          {Object.entries(section.extractedInformation).map(([key, value]) => (
            <div key={key} className="p-3 bg-gray-50 rounded-md">
              <div className="font-medium text-gray-700 mb-1 capitalize">
                {key.replace(/([A-Z])/g, ' $1').trim()}:
              </div>
              <div className="text-sm text-gray-600">
                {value || 'Not found'}
              </div>
            </div>
          ))}
        </div>
      </div>
      
      <div className="mb-6">
        <h4 className="font-medium mb-2">Evaluation Results</h4>
        <div className="space-y-3">
          {section.evaluationResults.map((result, index) => (
            <div key={index} className="p-3 bg-gray-50 rounded-md">
              <div className="flex justify-between items-center mb-2">
                <span className="font-medium">{result.criterion}</span>
                <span>
                  {getScoreIndicator(result.score)} {result.score}/{result.maxScore}
                </span>
              </div>
              <p className="text-sm text-gray-600">{result.comments}</p>
            </div>
          ))}
        </div>
      </div>
      
      {section.recommendations && section.recommendations.length > 0 && (
        <div>
          <h4 className="font-medium mb-2">Recommendations</h4>
          <div className="space-y-3">
            {section.recommendations.map((rec, index) => {
              const priorityClasses = {
                high: 'bg-red-50 text-red-700',
                medium: 'bg-yellow-50 text-yellow-700',
                low: 'bg-green-50 text-green-700'
              };
              
              return (
                <div key={index} className={`p-3 rounded-md ${priorityClasses[rec.priority]}`}>
                  <div className="font-medium">{rec.title}</div>
                  <div className="text-sm mt-1">{rec.description}</div>
                </div>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/components/forms/UploadForm.tsx">
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { RFPDocument, RFPSection } from '@/app/types';
import { FileProcessor } from '@/app/lib/fileProcessor';

export default function UploadForm() {
  const [file, setFile] = useState<File | null>(null);
  const [sections, setSections] = useState<Partial<RFPDocument>>({});
  const [manualInput, setManualInput] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState('');
  const [processingStatus, setProcessingStatus] = useState('');
  const router = useRouter();

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      const selectedFile = e.target.files[0];
      setFile(selectedFile);
      
      // Process the file if it's a supported type
      if (selectedFile) {
        try {
          setIsProcessing(true);
          setProcessingStatus('Processing file...');
          
          const result = await FileProcessor.processFile(selectedFile);
          
          if (result.error) {
            setError(result.error);
          } else {
            // Populate the sections from the parsed document
            setSections(result.document);
            setProcessingStatus('File processed successfully. You can review the extracted sections below.');
          }
        } catch (error) {
          setError('Error processing file: ' + (error instanceof Error ? error.message : 'Unknown error'));
        } finally {
          setIsProcessing(false);
        }
      }
    }
  };

  const handleSectionChange = (sectionName: keyof RFPDocument, value: string) => {
    setSections(prev => ({
      ...prev,
      [sectionName]: { content: value } as RFPSection
    }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError('');
    
    try {
      let document: RFPDocument;
      
      if (file && !manualInput) {
        document = sections;
      } else {
        document = sections as RFPDocument;
      }
      
      // Ensure we have at least one section
      if (Object.keys(document).length === 0) {
        throw new Error('No RFP sections found. Please upload a different file or enter sections manually.');
      }
      
      const response = await fetch('/api/analyze-rfp', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ document }),
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || 'Failed to analyze RFP');
      }
      
      router.push(`/results/${data.id}`);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="bg-white p-6 rounded-lg shadow-md">
      <div className="flex items-center mb-6">
        <div className="mr-6">
          <h3 className="text-lg font-semibold mb-2">Upload RFP Document</h3>
          <div className="border-2 border-dashed border-gray-300 rounded-lg p-4">
            <input
              title="RFP Document Upload"
              type="file"
              onChange={handleFileChange}
              accept=".pdf,.docx,.doc,.txt"
              className="block w-full text-sm text-gray-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-md file:border-0
                file:text-sm file:font-semibold
                file:bg-blue-50 file:text-blue-700
                hover:file:bg-blue-100"
              disabled={manualInput || isSubmitting || isProcessing}
            />
          </div>
          {isProcessing && (
            <div className="mt-2 text-sm text-blue-600">
              {processingStatus}
            </div>
          )}
        </div>
        
        <div className="flex items-center">
          <span className="text-lg font-semibold mx-4">OR</span>
        </div>
        
        <button
          type="button"
          onClick={() => setManualInput(!manualInput)}
          className={`px-4 py-2 rounded-md ${
            manualInput 
              ? 'bg-blue-600 text-white' 
              : 'bg-gray-100 text-gray-800'
          }`}
          disabled={isSubmitting || isProcessing}
        >
          Enter RFP Sections Manually
        </button>
      </div>
      
      {(manualInput || Object.keys(sections).length > 0) && (
        <div className="mb-6">
          <h3 className="text-lg font-semibold mb-4">
            {manualInput ? 'Enter RFP Sections' : 'Review Extracted Sections'}
          </h3>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Introduction
              </label>
              <textarea
                className="w-full p-2 border border-gray-300 rounded-md"
                rows={4}
                value={sections.introduction?.content || ''}
                onChange={(e) => handleSectionChange('introduction', e.target.value)}
                disabled={isSubmitting}
                placeholder={manualInput ? 'Enter introduction content...' : 'No introduction section found.'}
              />
            </div>
            
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Statement of Work (SOW)
              </label>
              <textarea
                className="w-full p-2 border border-gray-300 rounded-md"
                rows={4}
                value={sections.sow?.content || ''}
                onChange={(e) => handleSectionChange('sow', e.target.value)}
                disabled={isSubmitting}
                placeholder={manualInput ? 'Enter SOW content...' : 'No SOW section found.'}
              />
            </div>
            
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Proposal Submission
              </label>
              <textarea
                className="w-full p-2 border border-gray-300 rounded-md"
                rows={4}
                value={sections.proposalSubmission?.content || ''}
                onChange={(e) => handleSectionChange('proposalSubmission', e.target.value)}
                disabled={isSubmitting}
                placeholder={manualInput ? 'Enter submission requirements...' : 'No proposal submission section found.'}
              />
            </div>
            
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Evaluation Criteria
              </label>
              <textarea
                className="w-full p-2 border border-gray-300 rounded-md"
                rows={4}
                value={sections.evaluationCriteria?.content || ''}
                onChange={(e) => handleSectionChange('evaluationCriteria', e.target.value)}
                disabled={isSubmitting}
                placeholder={manualInput ? 'Enter evaluation criteria...' : 'No evaluation criteria section found.'}
              />
            </div>
            
            {/* Add more section fields as needed or implement a dynamic list */}
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Additional Notes
              </label>
              <textarea
                className="w-full p-2 border border-gray-300 rounded-md"
                rows={4}
                value={sections.additionalNotes?.content || ''}
                onChange={(e) => handleSectionChange('additionalNotes', e.target.value)}
                disabled={isSubmitting}
                placeholder={manualInput ? 'Enter additional notes...' : 'No additional notes section found.'}
              />
            </div>
            
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Additional Sections
              </label>
              <div className="p-3 bg-gray-50 rounded-md text-sm text-gray-600">
                {Object.keys(sections).length > 4 ? (
                  <p>{Object.keys(sections).length - 4} additional sections found. Use the full form for detailed editing.</p>
                ) : manualInput ? (
                  <p>Add more sections using the full form option.</p>
                ) : (
                  <p>No additional sections found in the document.</p>
                )}
              </div>
            </div>
          </div>
          
          {manualInput && (
            <button
              type="button"
              className="mt-2 text-blue-600 hover:underline text-sm"
              onClick={() => {/* Implement navigation to full form */}}
              title="Use full form to add all 18 sections"
              aria-label="Use full form to add all 18 sections"
              disabled={isSubmitting || isProcessing}
            >
              Use full form to add all 18 sections ‚Üí
            </button>
          )}
        </div>
      )}
      
      {error && (
        <div className="mb-4 p-3 bg-red-50 text-red-700 rounded-md">
          {error}
        </div>
      )}
      
      <button
        type="submit"
        className="px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:bg-gray-400"
        disabled={(Object.keys(sections).length === 0 && !manualInput) || isSubmitting || isProcessing}
      >
        {isSubmitting ? 'Analyzing...' : 'Analyze RFP'}
      </button>
    </form>
  );
}
</file>

<file path="src/app/components/layout/Navbar.tsx">
import Link from 'next/link';

export default function Navbar() {
  return (
    <nav className="bg-blue-600 text-white shadow-md">
      <div className="container mx-auto px-4 py-3 flex justify-between items-center">
        <Link href="/" className="text-xl font-bold">
          RFP Analyzer
        </Link>
        
        <div className="flex items-center space-x-6">
          <Link href="/" className="hover:underline">
            Home
          </Link>
          <Link href="/analyze" className="hover:underline">
            New Analysis
          </Link>
        </div>
      </div>
    </nav>
  );
}
</file>

<file path="src/app/components/layout/Sidebar.tsx">
import Link from 'next/link';

export default function Sidebar() {
  return (
    <div className="bg-white w-64 shadow-md min-h-screen p-4 hidden md:block">
      <div className="mb-8">
        <h2 className="text-lg font-semibold mb-4">RFP Sections</h2>
        <ul className="space-y-2">
          <li>
            <Link href="/guide/introduction" className="text-blue-600 hover:underline">
              Introduction
            </Link>
          </li>
          <li>
            <Link href="/guide/sow" className="text-blue-600 hover:underline">
              Statement of Work
            </Link>
          </li>
          <li>
            <Link href="/guide/proposal-submission" className="text-blue-600 hover:underline">
              Proposal Submission
            </Link>
          </li>
          <li>
            <Link href="/guide/evaluation-criteria" className="text-blue-600 hover:underline">
              Evaluation Criteria
            </Link>
          </li>
        </ul>
      </div>
      
      <div>
        <h2 className="text-lg font-semibold mb-4">Resources</h2>
        <ul className="space-y-2">
          <li>
            <Link href="/help" className="text-blue-600 hover:underline">
              Help & Documentation
            </Link>
          </li>
          <li>
            <Link href="/templates" className="text-blue-600 hover:underline">
              RFP Templates
            </Link>
          </li>
          <li>
            <Link href="/best-practices" className="text-blue-600 hover:underline">
              Best Practices
            </Link>
          </li>
        </ul>
      </div>
    </div>
  );
}
</file>

<file path="src/app/components/results/ExecutiveSummary.tsx">
interface ExecutiveSummaryProps {
  summary: {
    overallScore: number;
    summary: string;
    keyFindings: string[];
  };
}

export default function ExecutiveSummary({ summary }: ExecutiveSummaryProps) {
  const getScoreColor = (score: number) => {
    if (score >= 4) return 'text-green-600';
    if (score >= 3) return 'text-yellow-600';
    return 'text-red-600';
  };
  
  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-2xl font-bold">Executive Summary</h2>
        <div className="text-center">
          <div className={`text-3xl font-bold ${getScoreColor(summary.overallScore)}`}>
            {summary.overallScore.toFixed(1)}
          </div>
          <div className="text-sm text-gray-500">Overall Score</div>
        </div>
      </div>
      
      <div className="mb-6">
        <h3 className="text-lg font-semibold mb-2">Summary</h3>
        <p className="text-gray-700">{summary.summary}</p>
      </div>
      
      <div>
        <h3 className="text-lg font-semibold mb-2">Key Findings</h3>
        <ul className="space-y-2">
          {summary.keyFindings.map((finding, index) => (
            <li key={index} className="flex items-start">
              <span className="text-blue-500 mr-2">‚Ä¢</span>
              <span className="text-gray-700">{finding}</span>
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="src/app/layout.tsx">
import './globals.css';
import { Inter } from 'next/font/google';
import Navbar from './components/layout/Navbar';
import Sidebar from './components/layout/Sidebar';

const inter = Inter({ subsets: ['latin'] });

export const metadata = {
  title: 'RFP Analysis Tool',
  description: 'Analyze and evaluate RFP documents across multiple sections'
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={`${inter.className} bg-gray-50`}>
        <Navbar />
        <div className="flex">
          <Sidebar />
          <main className="flex-1 min-h-screen">
            {children}
          </main>
        </div>
      </body>
    </html>
  );
}
</file>

<file path="src/app/lib/analyzers/baseAnalyzer.ts">
import { EvaluationResult, Recommendation } from '@/app/types';

export abstract class SectionAnalyzer {
  protected sectionName: string;
  protected requiredElements: string[];
  protected evaluationCriteria: Array<{
    name: string;
    description: string;
  }>;

  constructor() {
    this.sectionName = 'Generic Section';
    this.requiredElements = [];
    this.evaluationCriteria = [];
  }

  analyze(sectionText: string) {
    const extractedInfo = this.extractInformation(sectionText);
    const evaluationResults = this.evaluateSection(extractedInfo, sectionText);
    const recommendations = this.generateRecommendations(extractedInfo, evaluationResults);
    
    return {
      sectionName: this.sectionName,
      extractedInformation: extractedInfo,
      evaluationResults,
      evaluationScore: this.calculateScore(evaluationResults),
      recommendations
    };
  }

  protected abstract extractInformation(sectionText: string): Record<string, string>;

  protected evaluateSection(
    extractedInfo: Record<string, string>, 
    sectionText: string
  ): EvaluationResult[] {
    return this.evaluationCriteria.map(criterion => {
      return {
        criterion: criterion.name,
        score: this.evaluateCriterion(criterion, extractedInfo, sectionText),
        maxScore: 5,
        comments: this.getCommentsForCriterion(criterion, extractedInfo, sectionText)
      };
    });
  }

  protected abstract evaluateCriterion(
    criterion: { name: string; description: string }, 
    extractedInfo: Record<string, string>, 
    sectionText: string
  ): number;

  protected abstract getCommentsForCriterion(
    criterion: { name: string; description: string }, 
    extractedInfo: Record<string, string>, 
    sectionText: string
  ): string;

  protected calculateScore(evaluationResults: EvaluationResult[]): number {
    if (evaluationResults.length === 0) return 0;
    
    const totalScore = evaluationResults.reduce((sum, result) => sum + result.score, 0);
    return parseFloat((totalScore / evaluationResults.length).toFixed(2));
  }

  protected generateRecommendations(
    extractedInfo: Record<string, string>, 
    evaluationResults: EvaluationResult[]
  ): Recommendation[] {
    const recommendations: Recommendation[] = [];
    
    // Find low-scoring criteria
    const lowScoreCriteria = evaluationResults.filter(result => result.score <= 3);
    
    for (const criterion of lowScoreCriteria) {
      recommendations.push({
        priority: criterion.score <= 2 ? 'high' : 'medium',
        section: this.sectionName,
        recommendation: `Address issues with ${criterion.criterion.toLowerCase()}: ${criterion.comments}`,
      });
    }
    
    // Add general recommendations
    if (recommendations.length === 0) {
      recommendations.push({
        priority: 'low',
        section: this.sectionName,
        recommendation: `Continue to maintain the high quality of the ${this.sectionName} section.`,
      });
    }
    
    return recommendations;
  }

  protected containsKeywords(text: string | undefined, keywords: string[]): boolean {
    if (!text) return false;
    const lowerText = text.toLowerCase();
    return keywords.some(keyword => lowerText.includes(keyword.toLowerCase()));
  }

  protected countKeywordOccurrences(text: string | undefined, keywords: string[]): number {
    if (!text) return 0;
    const lowerText = text.toLowerCase();
    return keywords.reduce((count, keyword) => {
      const regex = new RegExp(keyword.toLowerCase(), 'g');
      const matches = lowerText.match(regex);
      return count + (matches ? matches.length : 0);
    }, 0);
  }
}
</file>

<file path="src/app/lib/analyzers/certificationsAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class CertificationsAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Certifications and Representations';
    this.requiredElements = ['certifications', 'representations', 'compliance', 'forms'];
    this.evaluationCriteria = [
      {
        name: 'Required Certifications',
        description: 'Clear identification of required certifications'
      },
      {
        name: 'Required Representations',
        description: 'Clear identification of required representations'
      },
      {
        name: 'Submission Requirements',
        description: 'Clear requirements for submitting certifications and representations'
      },
      {
        name: 'Compliance References',
        description: 'References to applicable laws and regulations'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      requiredCertifications: this.extractRequiredCertifications(sectionText),
      requiredRepresentations: this.extractRequiredRepresentations(sectionText),
      submissionRequirements: this.extractSubmissionRequirements(sectionText),
      complianceReferences: this.extractComplianceReferences(sectionText)
    };
  }
  
  private extractRequiredCertifications(text: string): string {
    const certificationKeywords = [
      'certification', 'certify', 'certificate', 'certified',
      'self-certification', 'attest'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const certificationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, certificationKeywords)
    );
    
    return certificationSentences.join('. ');
  }
  
  private extractRequiredRepresentations(text: string): string {
    const representationKeywords = [
      'representation', 'represent', 'declare', 'declaration',
      'disclosure', 'disclose'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const representationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, representationKeywords)
    );
    
    return representationSentences.join('. ');
  }
  
  private extractSubmissionRequirements(text: string): string {
    const submissionKeywords = [
      'submit', 'submission', 'provide', 'include', 'form',
      'SAM', 'Representations and Certifications', 'ORCA'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const submissionSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, submissionKeywords)
    );
    
    return submissionSentences.join('. ');
  }
  
  private extractComplianceReferences(text: string): string {
    const complianceKeywords = [
      'comply', 'compliance', 'law', 'regulation', 'statute',
      'FAR', 'Federal Acquisition Regulation', 'requirement'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const complianceSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, complianceKeywords)
    );
    
    return complianceSentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): number {
    switch (criterion.name) {
      case 'Required Certifications':
        if (!extractedInfo.requiredCertifications) return 1;
        
        // Check for specific certification types
        const certificationTypeCount = this.countKeywordOccurrences(
          extractedInfo.requiredCertifications,
          ['small business', 'disadvantaged', 'woman-owned', 'veteran',
           'HUBZone', 'size', 'status', 'registration']
        );
        
        // Check for specific requirements
        const certificationDetail = extractedInfo.requiredCertifications.length;
        
        if (certificationTypeCount > 3 && certificationDetail > 150) return 5;
        if (certificationTypeCount > 1 && certificationDetail > 80) return 4;
        if (certificationTypeCount > 0 || certificationDetail > 80) return 3;
        return 2;
        
      case 'Required Representations':
        if (!extractedInfo.requiredRepresentations) return 1;
        
        // Check for specific representation types
        const representationTypeCount = this.countKeywordOccurrences(
          extractedInfo.requiredRepresentations,
          ['ethics', 'integrity', 'responsibility', 'debarment', 'suspension',
           'conflict of interest', 'tax', 'criminal']
        );
        
        // Check for representation detail
        const representationDetail = extractedInfo.requiredRepresentations.length;
        
        if (representationTypeCount > 3 && representationDetail > 150) return 5;
        if (representationTypeCount > 1 && representationDetail > 80) return 4;
        if (representationTypeCount > 0 || representationDetail > 80) return 3;
        return 2;
        
      case 'Submission Requirements':
        if (!extractedInfo.submissionRequirements) return 1;
        
        // Check for specific submission methods
        const hasSubmissionMethod = /form|SAM|System for Award Management|ORCA|online|electronic|submit with/i.test(
          extractedInfo.submissionRequirements
        );
        
        // Check for timing requirements
        const hasTimingRequirement = /before|prior|with|at time of|by|date|proposal|offer|bid/i.test(
          extractedInfo.submissionRequirements
        );
        
        if (hasSubmissionMethod && hasTimingRequirement) return 5;
        if (hasSubmissionMethod || hasTimingRequirement) return 4;
        if (extractedInfo.submissionRequirements.length > 50) return 3;
        return 2;
        
      case 'Compliance References':
        if (!extractedInfo.complianceReferences) return 1;
        
        // Check for specific regulatory references
        const regulationCount = this.countKeywordOccurrences(
          extractedInfo.complianceReferences,
          ['FAR', 'DFARS', 'CFR', 'USC', 'Public Law', 'section', 'clause']
        );
        
        // Check for specific citation format
        const hasCitationFormat = /\d+\.\d+|\d+\s+CFR|\d+\s+USC|\d+-\d+/i.test(
          extractedInfo.complianceReferences
        );
        
        if (regulationCount > 2 && hasCitationFormat) return 5;
        if (regulationCount > 0 && hasCitationFormat) return 4;
        if (regulationCount > 0 || hasCitationFormat) return 3;
        return 2;
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): string {
    switch (criterion.name) {
      case 'Required Certifications':
        if (!extractedInfo.requiredCertifications)
          return 'No certification requirements identified.';
        
        const certificationTypeCount = this.countKeywordOccurrences(
          extractedInfo.requiredCertifications,
          ['small business', 'disadvantaged', 'woman-owned', 'veteran',
           'HUBZone', 'size', 'status', 'registration']
        );
        
        const certificationDetail = extractedInfo.requiredCertifications.length;
        
        if (certificationTypeCount > 3 && certificationDetail > 150)
          return 'Comprehensive certification requirements with multiple specific types and detailed requirements.';
        if (certificationTypeCount > 1 && certificationDetail > 80)
          return 'Good certification requirements with specific types and some detail.';
        if (certificationTypeCount > 0)
          return 'Some specific certification types mentioned but could include more detail.';
        if (certificationDetail > 80)
          return 'Detailed certification information provided but specific types could be clearer.';
        return 'Basic certification information provided but lacks specificity.';
        
      case 'Required Representations':
        if (!extractedInfo.requiredRepresentations)
          return 'No representation requirements identified.';
        
        const representationTypeCount = this.countKeywordOccurrences(
          extractedInfo.requiredRepresentations,
          ['ethics', 'integrity', 'responsibility', 'debarment', 'suspension',
           'conflict of interest', 'tax', 'criminal']
        );
        
        const representationDetail = extractedInfo.requiredRepresentations.length;
        
        if (representationTypeCount > 3 && representationDetail > 150)
          return 'Comprehensive representation requirements with multiple specific types and detailed requirements.';
        if (representationTypeCount > 1 && representationDetail > 80)
          return 'Good representation requirements with specific types and some detail.';
        if (representationTypeCount > 0)
          return 'Some specific representation types mentioned but could include more detail.';
        if (representationDetail > 80)
          return 'Detailed representation information provided but specific types could be clearer.';
        return 'Basic representation information provided but lacks specificity.';
        
      case 'Submission Requirements':
        if (!extractedInfo.submissionRequirements)
          return 'No submission requirements for certifications and representations identified.';
        
        const hasSubmissionMethod = /form|SAM|System for Award Management|ORCA|online|electronic|submit with/i.test(
          extractedInfo.submissionRequirements
        );
        
        const hasTimingRequirement = /before|prior|with|at time of|by|date|proposal|offer|bid/i.test(
          extractedInfo.submissionRequirements
        );
        
        if (hasSubmissionMethod && hasTimingRequirement)
          return 'Clear submission requirements with specific method and timing for certifications and representations.';
        if (hasSubmissionMethod)
          return 'Submission method specified but timing requirements could be clearer.';
        if (hasTimingRequirement)
          return 'Submission timing requirements specified but method could be clearer.';
        return 'Basic submission information provided but lacks specificity.';
        
      case 'Compliance References':
        if (!extractedInfo.complianceReferences)
          return 'No compliance references identified.';
        
        const regulationCount = this.countKeywordOccurrences(
          extractedInfo.complianceReferences,
          ['FAR', 'DFARS', 'CFR', 'USC', 'Public Law', 'section', 'clause']
        );
        
        const hasCitationFormat = /\d+\.\d+|\d+\s+CFR|\d+\s+USC|\d+-\d+/i.test(
          extractedInfo.complianceReferences
        );
        
        if (regulationCount > 2 && hasCitationFormat)
          return 'Comprehensive compliance references with multiple specific regulations and proper citations.';
        if (regulationCount > 0 && hasCitationFormat)
          return 'Good compliance references with specific regulations and citations.';
        if (regulationCount > 0)
          return 'Some specific regulations mentioned but citations could be more precise.';
        if (hasCitationFormat)
          return 'Regulatory citations present but specific regulations could be clearer.';
        return 'Limited compliance reference information provided.';
        
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/contractDataAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class ContractDataAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Contract Data Requirements';
    this.requiredElements = ['deliverables', 'formats', 'schedules', 'standards'];
    this.evaluationCriteria = [
      {
        name: 'Data Deliverables',
        description: 'Clear identification of required data deliverables'
      },
      {
        name: 'Format Requirements',
        description: 'Clear requirements for data formats and standards'
      },
      {
        name: 'Delivery Schedule',
        description: 'Clear schedules for data deliverables'
      },
      {
        name: 'Quality Standards',
        description: 'Required quality standards for data deliverables'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      dataDeliverables: this.extractDataDeliverables(sectionText),
      formatRequirements: this.extractFormatRequirements(sectionText),
      deliverySchedule: this.extractDeliverySchedule(sectionText),
      qualityStandards: this.extractQualityStandards(sectionText)
    };
  }
  
  private extractDataDeliverables(text: string): string {
    const deliverableKeywords = [
      'deliverable', 'data', 'document', 'report', 'submit', 'provide',
      'CDRL', 'Contract Data Requirements List', 'DID'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const deliverableSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, deliverableKeywords)
    );
    
    return deliverableSentences.join('. ');
  }
  
  private extractFormatRequirements(text: string): string {
    const formatKeywords = [
      'format', 'standard', 'specification', 'template', 'file type',
      'electronic', 'digital', 'PDF', 'Microsoft Word', 'Excel'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const formatSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, formatKeywords)
    );
    
    return formatSentences.join('. ');
  }
  
  private extractDeliverySchedule(text: string): string {
    const scheduleKeywords = [
      'schedule', 'due date', 'frequency', 'timeline', 'delivery date',
      'submit by', 'monthly', 'quarterly', 'annual'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const scheduleSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, scheduleKeywords)
    );
    
    return scheduleSentences.join('. ');
  }
  
  private extractQualityStandards(text: string): string {
    const qualityKeywords = [
      'quality', 'standard', 'requirement', 'acceptance', 'review',
      'approve', 'reject', 'criteria'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const qualitySentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, qualityKeywords)
    );
    
    return qualitySentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
  ): number {
    switch (criterion.name) {
      case 'Data Deliverables':
        if (!extractedInfo.dataDeliverables) return 1;
        
        // Check for specific deliverable types
        const deliverableTypeCount = (extractedInfo.dataDeliverables.match(/report|document|plan|data|design|manual|specification/gi) || []).length;
        
        // Check for CDRL reference
        const hasCDRLReference = /CDRL|Contract Data Requirements List|DID|Data Item Description/i.test(
          extractedInfo.dataDeliverables
        );
        
        if (deliverableTypeCount > 3 && hasCDRLReference) return 5;
        if (deliverableTypeCount > 2 || (deliverableTypeCount > 0 && hasCDRLReference)) return 4;
        if (deliverableTypeCount > 0 || hasCDRLReference) return 3;
        return 2;
        
      case 'Format Requirements':
        if (!extractedInfo.formatRequirements) return 1;
        
        // Check for specific format types
        const formatTypeCount = this.countKeywordOccurrences(
          extractedInfo.formatRequirements,
          ['PDF', 'Word', 'Excel', 'PowerPoint', 'electronic', 'digital',
           'hard copy', 'paper', 'file type']
        );
        
        // Check for template or standard reference
        const hasTemplateReference = /template|standard|specification|conform to|in accordance with/i.test(
          extractedInfo.formatRequirements
        );
        
        if (formatTypeCount > 2 && hasTemplateReference) return 5;
        if (formatTypeCount > 0 && hasTemplateReference) return 4;
        if (formatTypeCount > 0 || hasTemplateReference) return 3;
        return 2;
        
      case 'Delivery Schedule':
        if (!extractedInfo.deliverySchedule) return 1;
        
        // Check for specific dates or timeframes
        const hasSpecificDates = /\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}\s+[a-z]+\s+\d{4}|20\d\d/i.test(
          extractedInfo.deliverySchedule
        );
        
        // Check for frequency terms
        const hasFrequencyTerms = /monthly|quarterly|weekly|bi-weekly|annual|semi-annual|days after/i.test(
          extractedInfo.deliverySchedule
        );
        
        if (hasSpecificDates && hasFrequencyTerms) return 5;
        if (hasSpecificDates || hasFrequencyTerms) return 4;
        if (extractedInfo.deliverySchedule.length > 50) return 3;
        return 2;
        
      case 'Quality Standards':
        if (!extractedInfo.qualityStandards) return 1;
        
        // Check for specific quality criteria
        const qualityCriteriaCount = this.countKeywordOccurrences(
          extractedInfo.qualityStandards,
          ['accurate', 'complete', 'current', 'consistent', 'error-free',
           'conform', 'compliance', 'acceptance criteria']
        );
        
        // Check for review process
        const hasReviewProcess = /review|approve|reject|revise|resubmit|acceptance/i.test(
          extractedInfo.qualityStandards
        );
        
        if (qualityCriteriaCount > 2 && hasReviewProcess) return 5;
        if (qualityCriteriaCount > 0 && hasReviewProcess) return 4;
        if (qualityCriteriaCount > 0 || hasReviewProcess) return 3;
        return 2;
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
        
  ): string {
    switch (criterion.name) {
      case 'Data Deliverables':
        if (!extractedInfo.dataDeliverables)
          return 'No data deliverable requirements identified.';
        
        const deliverableTypeCount = (extractedInfo.dataDeliverables.match(/report|document|plan|data|design|manual|specification/gi) || []).length;
        
        const hasCDRLReference = /CDRL|Contract Data Requirements List|DID|Data Item Description/i.test(
          extractedInfo.dataDeliverables
        );
        
        if (deliverableTypeCount > 3 && hasCDRLReference)
          return 'Comprehensive data deliverable requirements with multiple specific deliverable types and CDRL reference.';
        if (deliverableTypeCount > 2)
          return 'Multiple specific data deliverable types identified.';
        if (hasCDRLReference)
          return 'CDRL or Data Item Description referenced but specific deliverable types could be clearer.';
        if (deliverableTypeCount > 0)
          return 'Some data deliverable types mentioned but could be more comprehensive.';
        return 'Basic data deliverable information provided but lacks specificity.';
        
      case 'Format Requirements':
        if (!extractedInfo.formatRequirements)
          return 'No format requirements for data deliverables identified.';
        
        const formatTypeCount = this.countKeywordOccurrences(
          extractedInfo.formatRequirements,
          ['PDF', 'Word', 'Excel', 'PowerPoint', 'electronic', 'digital',
           'hard copy', 'paper', 'file type']
        );
        
        const hasTemplateReference = /template|standard|specification|conform to|in accordance with/i.test(
          extractedInfo.formatRequirements
        );
        
        if (formatTypeCount > 2 && hasTemplateReference)
          return 'Comprehensive format requirements with multiple specific formats and template/standard references.';
        if (formatTypeCount > 0 && hasTemplateReference)
          return 'Good format requirements with specific formats and template/standard references.';
        if (formatTypeCount > 0)
          return 'Specific format types mentioned but standards or templates could be clearer.';
        if (hasTemplateReference)
          return 'Template or standard requirements mentioned but specific formats could be clearer.';
        return 'Limited format requirement information provided.';
        
      case 'Delivery Schedule':
        if (!extractedInfo.deliverySchedule)
          return 'No delivery schedule for data deliverables identified.';
        
        const hasSpecificDates = /\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}\s+[a-z]+\s+\d{4}|20\d\d/i.test(
          extractedInfo.deliverySchedule
        );
        
        const hasFrequencyTerms = /monthly|quarterly|weekly|bi-weekly|annual|semi-annual|days after/i.test(
          extractedInfo.deliverySchedule
        );
        
        if (hasSpecificDates && hasFrequencyTerms)
          return 'Clear delivery schedule with specific dates and frequency requirements.';
        if (hasSpecificDates)
          return 'Specific delivery dates provided but frequency requirements could be clearer.';
        if (hasFrequencyTerms)
          return 'Delivery frequency requirements provided but specific dates could be clearer.';
        return 'Basic delivery schedule information provided but lacks specificity.';
        
      case 'Quality Standards':
        if (!extractedInfo.qualityStandards)
          return 'No quality standards for data deliverables identified.';
        
        const qualityCriteriaCount = this.countKeywordOccurrences(
          extractedInfo.qualityStandards,
          ['accurate', 'complete', 'current', 'consistent', 'error-free',
           'conform', 'compliance', 'acceptance criteria']
        );
        
        const hasReviewProcess = /review|approve|reject|revise|resubmit|acceptance/i.test(
          extractedInfo.qualityStandards
        );
        
        if (qualityCriteriaCount > 2 && hasReviewProcess)
          return 'Comprehensive quality standards with specific criteria and review process.';
        if (qualityCriteriaCount > 0 && hasReviewProcess)
          return 'Good quality standards with specific criteria and review process.';
        if (qualityCriteriaCount > 0 || hasReviewProcess)
          return 'Some quality criteria mentioned but could be more comprehensive.';
        return 'Basic quality standard information provided but lacks specificity.';
        
      default:
        return 'General comments for this criterion.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/contractTermsAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class ContractTermsAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Contract Terms';
    this.requiredElements = ['terms', 'conditions', 'clauses'];
    this.evaluationCriteria = [
      {
        name: 'Completeness',
        description: 'Inclusion of all required terms and conditions'
      },
      {
        name: 'Clarity',
        description: 'Clear and unambiguous language in contract terms'
      },
      {
        name: 'Regulatory Compliance',
        description: 'Compliance with applicable laws and regulations'
      },
      {
        name: 'Risk Allocation',
        description: 'Fair allocation of risks between parties'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      contractTerms: this.extractTerms(sectionText),
      contractConditions: this.extractConditions(sectionText),
      requiredClauses: this.extractClauses(sectionText),
      regulatoryReferences: this.extractRegulatoryReferences(sectionText),
      riskAllocation: this.extractRiskAllocation(sectionText)
    };
  }
  
  private extractTerms(text: string): string {
    const termKeywords = [
      'term', 'provision', 'agreement', 'contract', 'stipulation'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const termSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, termKeywords)
    );
    
    return termSentences.join('. ');
  }
  
  private extractConditions(text: string): string {
    const conditionKeywords = [
      'condition', 'requirement', 'contingent', 'dependent', 'subject to'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const conditionSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, conditionKeywords)
    );
    
    return conditionSentences.join('. ');
  }
  
  private extractClauses(text: string): string {
    const clauseKeywords = [
      'clause', 'section', 'provision', 'paragraph', 'article'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const clauseSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, clauseKeywords)
    );
    
    return clauseSentences.join('. ');
  }
  
  private extractRegulatoryReferences(text: string): string {
    const regulatoryKeywords = [
      'regulation', 'law', 'statute', 'act', 'code', 'compliance', 'legal'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const regulatorySentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, regulatoryKeywords)
    );
    
    return regulatorySentences.join('. ');
  }
  
  private extractRiskAllocation(text: string): string {
    const riskKeywords = [
      'risk', 'liability', 'responsible', 'indemnification', 'warranty', 'guarantee'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const riskSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, riskKeywords)
    );
    
    return riskSentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): number {
    switch (criterion.name) {
      case 'Completeness':
        const termCompleteness = extractedInfo.contractTerms?.length || 0;
        const conditionCompleteness = extractedInfo.contractConditions?.length || 0;
        const clauseCompleteness = extractedInfo.requiredClauses?.length || 0;
        
        const totalCompleteness = termCompleteness + conditionCompleteness + clauseCompleteness;
        return totalCompleteness > 300 ? 5 : 
               (totalCompleteness > 150 ? 4 : 
               (totalCompleteness > 50 ? 3 : 2));
      
      case 'Clarity':
        // Look for ambiguous language as negative indicator
        const ambiguityCount = this.countKeywordOccurrences(
          extractedInfo.contractTerms,
          ['ambiguity', 'unclear', 'vague', 'may', 'might', 'could', 'should']
        );
        
        const definitivesCount = this.countKeywordOccurrences(
          extractedInfo.contractTerms,
          ['shall', 'must', 'will', 'required', 'specific', 'defined']
        );
        
        // Higher ratio of definitives to ambiguities is better
        const clarityRatio = ambiguityCount === 0 ? definitivesCount : definitivesCount / ambiguityCount;
        return clarityRatio > 5 ? 5 :
               (clarityRatio > 3 ? 4 :
               (clarityRatio > 1 ? 3 : 2));
        
      case 'Regulatory Compliance':
        if (!extractedInfo.regulatoryReferences) return 2;
        
        const complianceCount = this.countKeywordOccurrences(
          extractedInfo.regulatoryReferences,
          ['comply', 'compliance', 'accordance', 'pursuant', 'regulation', 'law', 'statute']
        );
        
        return complianceCount > 5 ? 5 :
               (complianceCount > 3 ? 4 :
               (complianceCount > 1 ? 3 : 2));
        
      case 'Risk Allocation':
        if (!extractedInfo.riskAllocation) return 2;
        
        // Look for balanced risk language
        const fairnessCount = this.countKeywordOccurrences(
          extractedInfo.riskAllocation,
          ['fair', 'reasonable', 'appropriate', 'equitable', 'mutual', 'both parties']
        );
        
        // Look for one-sided risk language
        const onesidedCount = this.countKeywordOccurrences(
          extractedInfo.riskAllocation,
          ['sole', 'solely', 'exclusively', 'entirely', 'only']
        );
        
        // Higher fairness and lower one-sidedness is better
        const fairnessScore = fairnessCount - onesidedCount;
        return fairnessScore > 3 ? 5 :
               (fairnessScore > 1 ? 4 :
               (fairnessScore >= 0 ? 3 : 2));
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): string {
    switch (criterion.name) {
      case 'Completeness':
        const termCompleteness = extractedInfo.contractTerms?.length || 0;
        const conditionCompleteness = extractedInfo.contractConditions?.length || 0;
        const clauseCompleteness = extractedInfo.requiredClauses?.length || 0;
        
        const totalCompleteness = termCompleteness + conditionCompleteness + clauseCompleteness;
        
        if (totalCompleteness > 300)
          return 'Comprehensive terms and conditions covering all key contractual areas.';
        else if (totalCompleteness > 150)
          return 'Most major terms and conditions are addressed, but some areas could be more detailed.';
        else if (totalCompleteness > 50)
          return 'Basic contract terms are present but lack comprehensive coverage.';
        else
          return 'Contract terms are minimal or incomplete.';
        
      case 'Clarity':
        const ambiguityCount = this.countKeywordOccurrences(
          extractedInfo.contractTerms,
          ['ambiguity', 'unclear', 'vague', 'may', 'might', 'could', 'should']
        );
        
        const definitivesCount = this.countKeywordOccurrences(
          extractedInfo.contractTerms,
          ['shall', 'must', 'will', 'required', 'specific', 'defined']
        );
        
        const clarityRatio = ambiguityCount === 0 ? definitivesCount : definitivesCount / ambiguityCount;
        
        if (clarityRatio > 5)
          return 'Contract terms use clear, definitive language with minimal ambiguity.';
        else if (clarityRatio > 3)
          return 'Generally clear language with some potential ambiguities.';
        else if (clarityRatio > 1)
          return 'Contract language contains a moderate amount of ambiguous terms.';
        else
          return 'Contract terms contain significant ambiguity that could lead to disputes.';
        
      case 'Regulatory Compliance':
        if (!extractedInfo.regulatoryReferences)
          return 'No clear references to regulatory compliance requirements.';
        
        const complianceCount = this.countKeywordOccurrences(
          extractedInfo.regulatoryReferences,
          ['comply', 'compliance', 'accordance', 'pursuant', 'regulation', 'law', 'statute']
        );
        
        if (complianceCount > 5)
          return 'Strong emphasis on regulatory compliance with specific references to applicable laws.';
        else if (complianceCount > 3)
          return 'Good coverage of regulatory compliance with some specific references.';
        else if (complianceCount > 1)
          return 'Basic regulatory compliance addressed but lacks specific references.';
        else
          return 'Minimal attention to regulatory compliance requirements.';
        
      case 'Risk Allocation':
        if (!extractedInfo.riskAllocation)
          return 'No clear provisions for risk allocation between parties.';
        
        const fairnessCount = this.countKeywordOccurrences(
          extractedInfo.riskAllocation,
          ['fair', 'reasonable', 'appropriate', 'equitable', 'mutual', 'both parties']
        );
        
        const onesidedCount = this.countKeywordOccurrences(
          extractedInfo.riskAllocation,
          ['sole', 'solely', 'exclusively', 'entirely', 'only']
        );
        
        const fairnessScore = fairnessCount - onesidedCount;
        
        if (fairnessScore > 3)
          return 'Balanced risk allocation with fair and equitable terms for both parties.';
        else if (fairnessScore > 1)
          return 'Generally fair risk allocation with some imbalances.';
        else if (fairnessScore >= 0)
          return 'Mixed risk allocation with both fair and one-sided provisions.';
        else
          return 'Risk allocation appears to favor one party significantly over the other.';
        
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/cybersecurityAnalyzer.ts">
// /app/lib/analyzers/cybersecurityAnalyzer.ts
import { SectionAnalyzer } from './baseAnalyzer';

export class CybersecurityAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Cybersecurity Plan';
    this.requiredElements = ['requirements', 'standards', 'controls', 'compliance'];
    this.evaluationCriteria = [
      {
        name: 'Security Requirements',
        description: 'Clear identification of cybersecurity requirements'
      },
      {
        name: 'Standards Compliance',
        description: 'Specific security standards and frameworks required'
      },
      {
        name: 'Security Controls',
        description: 'Specific security controls or safeguards required'
      },
      {
        name: 'Evaluation Method',
        description: 'How cybersecurity plan will be evaluated'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      securityRequirements: this.extractSecurityRequirements(sectionText),
      standardsCompliance: this.extractStandardsCompliance(sectionText),
      securityControls: this.extractSecurityControls(sectionText),
      evaluationMethod: this.extractEvaluationMethod(sectionText)
    };
  }
  
  private extractSecurityRequirements(text: string): string {
    const securityKeywords = [
      'security', 'cybersecurity', 'requirement', 'protect', 'safeguard',
      'confidentiality', 'integrity', 'availability'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const securitySentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, securityKeywords)
    );
    
    return securitySentences.join('. ');
  }
  
  private extractStandardsCompliance(text: string): string {
    const standardsKeywords = [
      'standard', 'framework', 'NIST', 'FISMA', 'FedRAMP', 'ISO', '27001',
      'CMMC', 'SOC 2', 'compliance', 'comply'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const standardsSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, standardsKeywords)
    );
    
    return standardsSentences.join('. ');
  }
  
  private extractSecurityControls(text: string): string {
    const controlsKeywords = [
      'control', 'safeguard', 'measure', 'encryption', 'authentication',
      'access control', 'monitoring', 'incident response', 'backup'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const controlsSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, controlsKeywords)
    );
    
    return controlsSentences.join('. ');
  }
  
  private extractEvaluationMethod(text: string): string {
    const evaluationKeywords = [
      'evaluate', 'assess', 'review', 'factor', 'score', 'rating',
      'audit', 'examination'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const evaluationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, evaluationKeywords)
    );
    
    return evaluationSentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
  ): number {
    switch (criterion.name) {
      case 'Security Requirements':
        if (!extractedInfo.securityRequirements) return 1;
        
        // Check for specific requirements
        const securityRequirementCount = this.countKeywordOccurrences(
          extractedInfo.securityRequirements,
          ['protect', 'safeguard', 'ensure', 'maintain', 'implement',
           'confidentiality', 'integrity', 'availability']
        );
        
        // Check if data types are specified
        const hasDataTypeSpecification = /data|information|system|application|network|personal|sensitive|classified/i.test(
          extractedInfo.securityRequirements
        );
        
        if (securityRequirementCount > 3 && hasDataTypeSpecification) return 5;
        if (securityRequirementCount > 2 || (securityRequirementCount > 0 && hasDataTypeSpecification)) return 4;
        if (securityRequirementCount > 0 || hasDataTypeSpecification) return 3;
        return 2;
        
      case 'Standards Compliance':
        if (!extractedInfo.standardsCompliance) return 1;
        
        // Check for specific standards
        const standardCount = this.countKeywordOccurrences(
          extractedInfo.standardsCompliance,
          ['NIST', 'FISMA', 'FedRAMP', 'ISO', '27001', 'CMMC', 'SOC 2', 
           '800-53', '800-171']
        );
        
        // Check for compliance terms
        const hasComplianceRequirement = /comply|compliance|adhere|accordance|meet/i.test(
          extractedInfo.standardsCompliance
        );
        
        if (standardCount > 2 && hasComplianceRequirement) return 5;
        if (standardCount > 0 && hasComplianceRequirement) return 4;
        if (standardCount > 0 || hasComplianceRequirement) return 3;
        return 2;
        
      case 'Security Controls':
        if (!extractedInfo.securityControls) return 1;
        
        // Check for specific control types
        const controlTypeCount = this.countKeywordOccurrences(
          extractedInfo.securityControls,
          ['encryption', 'authentication', 'access control', 'monitoring',
           'incident response', 'backup', 'recovery', 'patch', 'update']
        );
        
        // Check control detail
        const controlDetail = extractedInfo.securityControls.length;
        
        if (controlTypeCount > 3 && controlDetail > 150) return 5;
        if (controlTypeCount > 1 && controlDetail > 100) return 4;
        if (controlTypeCount > 0) return 3;
        return 2;
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod) return 1;
        
        // Check for evaluation approach
        const hasEvaluationApproach = /review|assess|evaluate|audit|examination|test/i.test(
          extractedInfo.evaluationMethod
        );
        
        // Check for specific criteria
        const hasCriteria = /criteria|factor|score|rating|acceptable|adequate/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (hasEvaluationApproach && hasCriteria) return 5;
        if (hasEvaluationApproach || hasCriteria) return 4;
        if (extractedInfo.evaluationMethod.length > 50) return 3;
        return 2;
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
  ): string {
    switch (criterion.name) {
      case 'Security Requirements':
        if (!extractedInfo.securityRequirements)
          return 'No cybersecurity requirements identified.';
        
        const securityRequirementCount = this.countKeywordOccurrences(
          extractedInfo.securityRequirements,
          ['protect', 'safeguard', 'ensure', 'maintain', 'implement',
           'confidentiality', 'integrity', 'availability']
        );
        
        const hasDataTypeSpecification = /data|information|system|application|network|personal|sensitive|classified/i.test(
          extractedInfo.securityRequirements
        );
        
        if (securityRequirementCount > 3 && hasDataTypeSpecification)
          return 'Comprehensive cybersecurity requirements with specific protections and data types identified.';
        if (securityRequirementCount > 2)
          return 'Multiple specific cybersecurity requirements identified.';
        if (hasDataTypeSpecification)
          return 'Data types requiring protection are specified but security requirements could be more detailed.';
        if (securityRequirementCount > 0)
          return 'Basic security requirements mentioned but could be more comprehensive.';
        return 'Limited cybersecurity requirements provided.';
        
      case 'Standards Compliance':
        if (!extractedInfo.standardsCompliance)
          return 'No cybersecurity standards compliance requirements identified.';
        
        const standardCount = this.countKeywordOccurrences(
          extractedInfo.standardsCompliance,
          ['NIST', 'FISMA', 'FedRAMP', 'ISO', '27001', 'CMMC', 'SOC 2', 
           '800-53', '800-171']
        );
        
        const hasComplianceRequirement = /comply|compliance|adhere|accordance|meet/i.test(
          extractedInfo.standardsCompliance
        );
        
        if (standardCount > 2 && hasComplianceRequirement)
          return 'Comprehensive standards compliance requirements with multiple specific frameworks identified.';
        if (standardCount > 0 && hasComplianceRequirement)
          return 'Good standards compliance requirements with specific frameworks referenced.';
        if (standardCount > 0)
          return 'Specific security frameworks mentioned but compliance requirements could be clearer.';
        if (hasComplianceRequirement)
          return 'Compliance requirements mentioned but specific frameworks could be clearer.';
        return 'Limited standards compliance information provided.';
        
      case 'Security Controls':
        if (!extractedInfo.securityControls)
          return 'No security controls or safeguards identified.';
        
        const controlTypeCount = this.countKeywordOccurrences(
          extractedInfo.securityControls,
          ['encryption', 'authentication', 'access control', 'monitoring',
           'incident response', 'backup', 'recovery', 'patch', 'update']
        );
        
        const controlDetail = extractedInfo.securityControls.length;
        
        if (controlTypeCount > 3 && controlDetail > 150)
          return 'Comprehensive security controls with multiple specific control types and detailed requirements.';
        if (controlTypeCount > 1 && controlDetail > 100)
          return 'Good security controls with multiple control types identified.';
        if (controlTypeCount > 0)
          return 'Specific security control types mentioned but could be more comprehensive.';
        return 'Limited security control information provided.';
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod)
          return 'No evaluation method for cybersecurity plan identified.';
        
        const hasEvaluationApproach = /review|assess|evaluate|audit|examination|test/i.test(
          extractedInfo.evaluationMethod
        );
        
        const hasCriteria = /criteria|factor|score|rating|acceptable|adequate/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (hasEvaluationApproach && hasCriteria)
          return 'Clear evaluation method with specific approach and criteria for cybersecurity plan.';
        if (hasEvaluationApproach)
          return 'Evaluation approach specified but criteria could be clearer.';
        if (hasCriteria)
          return 'Evaluation criteria specified but approach could be clearer.';
        return 'Limited evaluation method information provided.';
        
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/environmentalAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class EnvironmentalAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Environmental Considerations';
    this.requiredElements = ['requirements', 'compliance', 'sustainability'];
    this.evaluationCriteria = [
      {
        name: 'Regulatory Requirements',
        description: 'Clear identification of applicable environmental regulations'
      },
      {
        name: 'Compliance Verification',
        description: 'Methods for verifying environmental compliance'
      },
      {
        name: 'Sustainability Requirements',
        description: 'Requirements for sustainable practices or certifications'
      },
      {
        name: 'Evaluation Method',
        description: 'How environmental considerations will be evaluated'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      regulatoryRequirements: this.extractRegulatoryRequirements(sectionText),
      complianceVerification: this.extractComplianceVerification(sectionText),
      sustainabilityRequirements: this.extractSustainabilityRequirements(sectionText),
      evaluationMethod: this.extractEvaluationMethod(sectionText)
    };
  }
  
  private extractRegulatoryRequirements(text: string): string {
    const regulatoryKeywords = [
      'regulation', 'law', 'requirement', 'EPA', 'environmental protection', 
      'Clean Air', 'Clean Water', 'hazardous', 'waste', 'disposal'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const regulatorySentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, regulatoryKeywords)
    );
    
    return regulatorySentences.join('. ');
  }
  
  private extractComplianceVerification(text: string): string {
    const complianceKeywords = [
      'compliance', 'verify', 'demonstrate', 'certification', 'audit',
      'documentation', 'report', 'monitor'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const complianceSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, complianceKeywords)
    );
    
    return complianceSentences.join('. ');
  }
  
  private extractSustainabilityRequirements(text: string): string {
    const sustainabilityKeywords = [
      'sustainability', 'sustainable', 'green', 'recycled', 'renewable',
      'energy efficiency', 'carbon', 'footprint', 'eco-friendly'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const sustainabilitySentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, sustainabilityKeywords)
    );
    
    return sustainabilitySentences.join('. ');
  }
  
  private extractEvaluationMethod(text: string): string {
    const evaluationKeywords = [
      'evaluate', 'assess', 'factor', 'consider', 'score', 'rating',
      'preference', 'priority'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const evaluationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, evaluationKeywords)
    );
    
    return evaluationSentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
  ): number {
    switch (criterion.name) {
      case 'Regulatory Requirements':
        if (!extractedInfo.regulatoryRequirements) return 1;
        
        // Check for specific regulations
        const specificRegulationCount = this.countKeywordOccurrences(
          extractedInfo.regulatoryRequirements,
          ['EPA', 'Clean Air Act', 'Clean Water Act', 'RCRA', 'CERCLA',
           'NEPA', 'ESA', 'TSCA']
        );
        
        // Check for general environmental terms
        const environmentalTermCount = this.countKeywordOccurrences(
          extractedInfo.regulatoryRequirements,
          ['hazardous', 'waste', 'disposal', 'emission', 'discharge',
           'pollution', 'contamination']
        );
        
        if (specificRegulationCount > 2 && environmentalTermCount > 2) return 5;
        if (specificRegulationCount > 0 && environmentalTermCount > 1) return 4;
        if (specificRegulationCount > 0 || environmentalTermCount > 1) return 3;
        return 2;
        
      case 'Compliance Verification':
        if (!extractedInfo.complianceVerification) return 1;
        
        // Check for verification methods
        const verificationMethodCount = this.countKeywordOccurrences(
          extractedInfo.complianceVerification,
          ['certification', 'audit', 'documentation', 'report', 'monitor',
           'inspection', 'verification']
        );
        
        if (verificationMethodCount > 2 && extractedInfo.complianceVerification.length > 100) return 5;
        if (verificationMethodCount > 1) return 4;
        if (verificationMethodCount > 0) return 3;
        return 2;
        
      case 'Sustainability Requirements':
        if (!extractedInfo.sustainabilityRequirements) return 2; // Not always required
        
        // Check for specific sustainability requirements
        const sustainabilityRequirementCount = this.countKeywordOccurrences(
          extractedInfo.sustainabilityRequirements,
          ['recycled', 'renewable', 'energy efficiency', 'carbon', 'footprint',
           'reduction', 'minimize', 'conserve']
        );
        
        // Check for certification requirements
        const hasCertificationRequirements = /certification|certified|LEED|Energy Star|Green Seal/i.test(
          extractedInfo.sustainabilityRequirements
        );
        
        if (sustainabilityRequirementCount > 2 && hasCertificationRequirements) return 5;
        if (sustainabilityRequirementCount > 1 || hasCertificationRequirements) return 4;
        if (sustainabilityRequirementCount > 0) return 3;
        return 2;
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod) return 2; // Not always detailed
        
        // Check for specific evaluation criteria
        const hasEvaluationCriteria = /factor|weight|consider|score|rating|preference/i.test(
          extractedInfo.evaluationMethod
        );
        
        // Check if sustainability is an evaluation factor
        const isSustainabilityFactor = /sustainability|environmental|green/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (hasEvaluationCriteria && isSustainabilityFactor) return 5;
        if (hasEvaluationCriteria || isSustainabilityFactor) return 4;
        if (extractedInfo.evaluationMethod.length > 50) return 3;
        return 2;
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
  ): string {
    switch (criterion.name) {
      case 'Regulatory Requirements':
        if (!extractedInfo.regulatoryRequirements)
          return 'No environmental regulatory requirements identified.';
        
        const specificRegulationCount = this.countKeywordOccurrences(
          extractedInfo.regulatoryRequirements,
          ['EPA', 'Clean Air Act', 'Clean Water Act', 'RCRA', 'CERCLA',
           'NEPA', 'ESA', 'TSCA']
        );
        
        const environmentalTermCount = this.countKeywordOccurrences(
          extractedInfo.regulatoryRequirements,
          ['hazardous', 'waste', 'disposal', 'emission', 'discharge',
           'pollution', 'contamination']
        );
        
        if (specificRegulationCount > 2 && environmentalTermCount > 2)
          return 'Comprehensive environmental regulatory requirements with specific regulations and environmental terms.';
        if (specificRegulationCount > 0 && environmentalTermCount > 1)
          return 'Good environmental requirements with some specific regulations and environmental terms.';
        if (specificRegulationCount > 0)
          return 'Some specific environmental regulations mentioned but could include more environmental terms.';
        if (environmentalTermCount > 1)
          return 'Environmental terms referenced but specific regulations could be clearer.';
        return 'Limited environmental regulatory information provided.';
        
      case 'Compliance Verification':
        if (!extractedInfo.complianceVerification)
          return 'No compliance verification methods identified.';
        
        const verificationMethodCount = this.countKeywordOccurrences(
          extractedInfo.complianceVerification,
          ['certification', 'audit', 'documentation', 'report', 'monitor',
           'inspection', 'verification']
        );
        
        if (verificationMethodCount > 2 && extractedInfo.complianceVerification.length > 100)
          return 'Comprehensive compliance verification methods with multiple specific approaches.';
        if (verificationMethodCount > 1)
          return 'Multiple compliance verification methods specified.';
        if (verificationMethodCount > 0)
          return 'Basic compliance verification method mentioned but could be more comprehensive.';
        return 'Limited compliance verification information provided.';
        
      case 'Sustainability Requirements':
        if (!extractedInfo.sustainabilityRequirements)
          return 'No sustainability requirements identified.';
        
        const sustainabilityRequirementCount = this.countKeywordOccurrences(
          extractedInfo.sustainabilityRequirements,
          ['recycled', 'renewable', 'energy efficiency', 'carbon', 'footprint',
           'reduction', 'minimize', 'conserve']
        );
        
        const hasCertificationRequirements = /certification|certified|LEED|Energy Star|Green Seal/i.test(
          extractedInfo.sustainabilityRequirements
        );
        
        if (sustainabilityRequirementCount > 2 && hasCertificationRequirements)
          return 'Comprehensive sustainability requirements with specific measures and certification requirements.';
        if (sustainabilityRequirementCount > 1)
          return 'Multiple sustainability requirements specified.';
        if (hasCertificationRequirements)
          return 'Sustainability certification requirements specified.';
        if (sustainabilityRequirementCount > 0)
          return 'Basic sustainability requirements mentioned but could be more comprehensive.';
        return 'Limited sustainability information provided.';
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod)
          return 'No evaluation method for environmental considerations identified.';
        
        const hasEvaluationCriteria = /factor|weight|consider|score|rating|preference/i.test(
          extractedInfo.evaluationMethod
        );
        
        const isSustainabilityFactor = /sustainability|environmental|green/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (hasEvaluationCriteria && isSustainabilityFactor)
          return 'Clear evaluation method with sustainability as a specific evaluation factor.';
        if (hasEvaluationCriteria)
          return 'Evaluation criteria specified but sustainability as a factor could be clearer.';
        if (isSustainabilityFactor)
          return 'Sustainability identified as an evaluation factor but scoring approach could be clearer.';
        return 'Limited evaluation information for environmental considerations provided.';
        
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/evaluationCriteriaAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class EvaluationCriteriaAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Evaluation Criteria';
    this.requiredElements = ['factors', 'weights', 'assessment_method'];
    this.evaluationCriteria = [
      {
        name: 'Factor Definition',
        description: 'Clarity and comprehensiveness of evaluation factors'
      },
      {
        name: 'Weighting System',
        description: 'Clear definition of relative importance of factors'
      },
      {
        name: 'Assessment Methodology',
        description: 'Clarity of how proposals will be evaluated'
      },
      {
        name: 'Objectivity',
        description: 'Objective and measurable evaluation criteria'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      evaluationFactors: this.extractFactors(sectionText),
      weightSystem: this.extractWeights(sectionText),
      assessmentMethod: this.extractAssessmentMethod(sectionText),
      objectivityMeasures: this.extractObjectivityMeasures(sectionText)
    };
  }
  
  private extractFactors(text: string): string {
    const factorKeywords = [
      'factor', 'criteria', 'evaluate', 'consideration', 'aspect', 'element'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const factorSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, factorKeywords)
    );
    
    return factorSentences.join('. ');
  }
  
  private extractWeights(text: string): string {
    const weightKeywords = [
      'weight', 'importance', 'priority', 'percentage', 'point', 'score'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const weightSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, weightKeywords)
    );
    
    return weightSentences.join('. ');
  }
  
  private extractAssessmentMethod(text: string): string {
    const methodKeywords = [
      'method', 'approach', 'process', 'procedure', 'evaluate', 'assess'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const methodSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, methodKeywords)
    );
    
    return methodSentences.join('. ');
  }
  
  private extractObjectivityMeasures(text: string): string {
    const objectivityKeywords = [
      'objective', 'measurable', 'quantitative', 'specific', 'fair', 'neutral'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const objectivitySentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, objectivityKeywords)
    );
    
    return objectivitySentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): number {
    switch (criterion.name) {
      case 'Factor Definition':
        if (!extractedInfo.evaluationFactors) return 1;
        return extractedInfo.evaluationFactors.length > 150 ? 5 : 
               (extractedInfo.evaluationFactors.length > 80 ? 4 : 3);
               
      case 'Weighting System':
        if (!extractedInfo.weightSystem) return 1;
        const hasNumericWeights = /\d+\s*%|\d+\s*point/.test(extractedInfo.weightSystem);
        return hasNumericWeights ? 5 : 
               (extractedInfo.weightSystem.length > 50 ? 3 : 2);
               
      case 'Assessment Methodology':
        if (!extractedInfo.assessmentMethod) return 1;
        return extractedInfo.assessmentMethod.length > 100 ? 5 : 
               (extractedInfo.assessmentMethod.length > 50 ? 4 : 3);
               
      case 'Objectivity':
        if (!extractedInfo.objectivityMeasures) return 1;
        const hasObjectiveLanguage = this.countKeywordOccurrences(
          extractedInfo.objectivityMeasures, 
          ['measurable', 'quantitative', 'specific', 'metric']
        );
        return hasObjectiveLanguage > 3 ? 5 : 
               (hasObjectiveLanguage > 1 ? 4 : 3);
               
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
  ): string {
    switch (criterion.name) {
      case 'Factor Definition':
        if (!extractedInfo.evaluationFactors)
          return 'No clear evaluation factors identified.';
        return extractedInfo.evaluationFactors.length > 150 ?
          'Evaluation factors are comprehensively defined.' :
          'Basic evaluation factors mentioned but could be more detailed.';
          
      case 'Weighting System':
        if (!extractedInfo.weightSystem)
          return 'No weighting system identified.';
        const hasNumericWeights = /\d+\s*%|\d+\s*point/.test(extractedInfo.weightSystem);
        return hasNumericWeights ?
          'Clear numeric weights assigned to evaluation factors.' :
          'Relative importance mentioned but lacks specific weighting values.';
          
      case 'Assessment Methodology':
        if (!extractedInfo.assessmentMethod)
          return 'No assessment methodology identified.';
        return extractedInfo.assessmentMethod.length > 100 ?
          'Assessment methodology is clearly defined with specific procedures.' :
          'Basic assessment approach mentioned but lacks procedural details.';
          
      case 'Objectivity':
        if (!extractedInfo.objectivityMeasures)
          return 'No objectivity measures identified.';
        const objectiveCount = this.countKeywordOccurrences(
          extractedInfo.objectivityMeasures, 
          ['measurable', 'quantitative', 'specific', 'metric']
        );
        return objectiveCount > 3 ?
          'Strong emphasis on objective and measurable evaluation criteria.' :
          'Limited emphasis on objective measurement in evaluation criteria.';
          
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/index.ts">
export * from './baseAnalyzer';
export * from './introductionAnalyzer';
export * from './sowAnalyzer';
export * from './proposalSubmissionAnalyzer';
export * from './evaluationCriteriaAnalyzer';
export * from './contractTermsAnalyzer';
export * from './priceCostProposalAnalyzer';
export * from './periodOfPerformanceAnalyzer';
export * from './keyPersonnelAnalyzer';
export * from './pastPerformanceAnalyzer';
export * from './subcontractingPlanAnalyzer';
export * from './environmentalAnalyzer';
export * from './cybersecurityAnalyzer';
export * from './supplyChainRiskAnalyzer';
export * from './contractDataAnalyzer';
export * from './certificationsAnalyzer';
export * from './technicalApproachAnalyzer';
export * from './managementApproachAnalyzer';
export * from './riskAssessmentAnalyzer';
</file>

<file path="src/app/lib/analyzers/introductionAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class IntroductionAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Introduction';
    this.requiredElements = ['purpose', 'background', 'requirements'];
    this.evaluationCriteria = [
      {
        name: 'Purpose Clarity',
        description: 'Clarity of the solicitation\'s purpose and objectives'
      },
      {
        name: 'Background Information',
        description: 'Completeness of project/requirement background'
      },
      {
        name: 'Requirements Compliance',
        description: 'Alignment with organizational and regulatory requirements'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      purpose: this.extractPurpose(sectionText),
      background: this.extractBackground(sectionText),
      requirements: this.extractRequirements(sectionText)
    };
  }
  
  private extractPurpose(text: string): string {
    const purposeKeywords = [
      'purpose', 'objective', 'goal', 'intent', 'aim'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const purposeSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, purposeKeywords)
    );
    
    return purposeSentences.join('. ');
  }
  
  private extractBackground(text: string): string {
    const backgroundKeywords = [
      'background', 'history', 'context', 'previously', 'overview'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const backgroundSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, backgroundKeywords)
    );
    
    return backgroundSentences.join('. ');
  }
  
  private extractRequirements(text: string): string {
    const requirementKeywords = [
      'requirement', 'must', 'shall', 'required', 'mandatory', 'comply'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const requirementSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, requirementKeywords)
    );
    
    return requirementSentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
  ): number {
    switch (criterion.name) {
      case 'Purpose Clarity':
        if (!extractedInfo.purpose) return 1;
        return extractedInfo.purpose.length > 50 ? 
          (extractedInfo.purpose.length > 150 ? 5 : 4) : 2;
        
      case 'Background Information':
        if (!extractedInfo.background) return 1;
        return extractedInfo.background.length > 100 ? 
          (extractedInfo.background.length > 300 ? 5 : 4) : 3;
        
      case 'Requirements Compliance':
        if (!extractedInfo.requirements) return 1;
        const requirementsCompliance = this.countKeywordOccurrences(
          extractedInfo.requirements, ['comply', 'compliance', 'regulation', 'standard']
        );
        return requirementsCompliance > 3 ? 5 : (requirementsCompliance > 1 ? 4 : 3);
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): string {
    switch (criterion.name) {
      case 'Purpose Clarity':
        if (!extractedInfo.purpose) 
          return 'No clear purpose statement found.';
        return extractedInfo.purpose.length > 150 ?
          'Clear and comprehensive purpose statement provided.' :
          'Purpose statement present but could be more detailed.';
          
      case 'Background Information':
        if (!extractedInfo.background)
          return 'No background information provided.';
        return extractedInfo.background.length > 300 ?
          'Thorough background information provided.' :
          'Some background information provided, but more context would be helpful.';
          
      case 'Requirements Compliance':
        if (!extractedInfo.requirements)
          return 'No clear requirements statements found.';
        const complianceCount = this.countKeywordOccurrences(
          extractedInfo.requirements, ['comply', 'compliance', 'regulation', 'standard']
        );
        return complianceCount > 3 ?
          'Strong emphasis on regulatory compliance.' :
          'Limited discussion of compliance requirements.';
          
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/keyPersonnelAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class KeyPersonnelAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Key Personnel';
    this.requiredElements = ['roles', 'qualifications', 'responsibilities', 'availability'];
    this.evaluationCriteria = [
      {
        name: 'Role Definition',
        description: 'Clear definition of key personnel roles and responsibilities'
      },
      {
        name: 'Qualification Requirements',
        description: 'Specificity of required qualifications and experience'
      },
      {
        name: 'Substitution Provisions',
        description: 'Clear process for personnel substitutions or changes'
      },
      {
        name: 'Commitment Requirements',
        description: 'Clear requirements for personnel availability and commitment'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      roles: this.extractRoles(sectionText),
      qualifications: this.extractQualifications(sectionText),
      substitution: this.extractSubstitution(sectionText),
      commitment: this.extractCommitment(sectionText)
    };
  }
  
  private extractRoles(text: string): string {
    const roleKeywords = [
      'role', 'position', 'title', 'responsibility', 'duty', 'function', 'job'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const roleSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, roleKeywords)
    );
    
    return roleSentences.join('. ');
  }
  
  private extractQualifications(text: string): string {
    const qualificationKeywords = [
      'qualification', 'experience', 'education', 'skill', 'certification',
      'degree', 'knowledge', 'competency', 'expertise'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const qualificationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, qualificationKeywords)
    );
    
    return qualificationSentences.join('. ');
  }
  
  private extractSubstitution(text: string): string {
    const substitutionKeywords = [
      'substitution', 'replacement', 'change', 'alternate', 'approval'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const substitutionSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, substitutionKeywords)
    );
    
    return substitutionSentences.join('. ');
  }
  
  private extractCommitment(text: string): string {
    const commitmentKeywords = [
      'commitment', 'availability', 'dedication', 'time', 'allocation', 
      'full-time', 'part-time', 'percentage'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const commitmentSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, commitmentKeywords)
    );
    
    return commitmentSentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
  ): number {
    switch (criterion.name) {
      case 'Role Definition':
        if (!extractedInfo.roles) return 1;
        
        // Check for specific role titles
        const hasSpecificRoles = /project manager|developer|engineer|analyst|director|lead|architect/i.test(
          extractedInfo.roles
        );
        
        // Check if responsibilities are detailed
        const responsibilityDetail = extractedInfo.roles.length;
        
        if (hasSpecificRoles && responsibilityDetail > 200) return 5;
        if (hasSpecificRoles && responsibilityDetail > 100) return 4;
        if (hasSpecificRoles || responsibilityDetail > 100) return 3;
        return 2;
        
      case 'Qualification Requirements':
        if (!extractedInfo.qualifications) return 1;
        
        // Check for specific qualification metrics
        const hasSpecificQualifications = /\d+\s+years|degree|certification|bachelor|master|phd|professional/i.test(
          extractedInfo.qualifications
        );
        
        // Check qualification detail
        const qualificationDetail = extractedInfo.qualifications.length;
        
        if (hasSpecificQualifications && qualificationDetail > 200) return 5;
        if (hasSpecificQualifications && qualificationDetail > 100) return 4;
        if (hasSpecificQualifications || qualificationDetail > 100) return 3;
        return 2;
        
      case 'Substitution Provisions':
        if (!extractedInfo.substitution) return 2; // Not always required
        
        // Check for approval process
        const hasApprovalProcess = /approval|approve|written|consent|prior/i.test(
          extractedInfo.substitution
        );
        
        // Check for equivalency requirements
        const hasEquivalencyRequirements = /equivalent|equal|same|similar|comparable/i.test(
          extractedInfo.substitution
        );
        
        if (hasApprovalProcess && hasEquivalencyRequirements) return 5;
        if (hasApprovalProcess || hasEquivalencyRequirements) return 4;
        if (extractedInfo.substitution.length > 50) return 3;
        return 2;
        
      case 'Commitment Requirements':
        if (!extractedInfo.commitment) return 2; // Not always detailed
        
        // Check for specific time commitments
        const hasSpecificCommitment = /\d+%|\d+\s+hours|full-time|part-time/i.test(
          extractedInfo.commitment
        );
        
        // Check for duration commitments
        const hasDurationCommitment = /duration|throughout|entire|period of performance/i.test(
          extractedInfo.commitment
        );
        
        if (hasSpecificCommitment && hasDurationCommitment) return 5;
        if (hasSpecificCommitment || hasDurationCommitment) return 4;
        if (extractedInfo.commitment.length > 50) return 3;
        return 2;
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
  ): string {
    switch (criterion.name) {
      case 'Role Definition':
        if (!extractedInfo.roles)
          return 'No clear role definitions identified.';
        
        const hasSpecificRoles = /project manager|developer|engineer|analyst|director|lead|architect/i.test(
          extractedInfo.roles
        );
        
        const responsibilityDetail = extractedInfo.roles.length;
        
        if (hasSpecificRoles && responsibilityDetail > 200)
          return 'Comprehensive definition of key personnel roles with detailed responsibilities.';
        if (hasSpecificRoles && responsibilityDetail > 100)
          return 'Good definition of key roles with responsibilities outlined.';
        if (hasSpecificRoles)
          return 'Specific roles are identified but responsibilities could be more detailed.';
        if (responsibilityDetail > 100)
          return 'Responsibilities are described but specific role titles could be clearer.';
        return 'Basic role information provided but lacks specificity.';
        
      case 'Qualification Requirements':
        if (!extractedInfo.qualifications)
          return 'No qualification requirements identified.';
        
        const hasSpecificQualifications = /\d+\s+years|degree|certification|bachelor|master|phd|professional/i.test(
          extractedInfo.qualifications
        );
        
        const qualificationDetail = extractedInfo.qualifications.length;
        
        if (hasSpecificQualifications && qualificationDetail > 200)
          return 'Comprehensive qualification requirements with specific experience, education, and certification details.';
        if (hasSpecificQualifications && qualificationDetail > 100)
          return 'Good qualification requirements with specific metrics for experience or education.';
        if (hasSpecificQualifications)
          return 'Specific qualification metrics mentioned but could be more comprehensive.';
        if (qualificationDetail > 100)
          return 'Qualifications are described but specific requirements could be clearer.';
        return 'Basic qualification information provided but lacks specific metrics.';
        
      case 'Substitution Provisions':
        if (!extractedInfo.substitution)
          return 'No substitution provisions identified. Consider adding a process for personnel changes.';
        
        const hasApprovalProcess = /approval|approve|written|consent|prior/i.test(
          extractedInfo.substitution
        );
        
        const hasEquivalencyRequirements = /equivalent|equal|same|similar|comparable/i.test(
          extractedInfo.substitution
        );
        
        if (hasApprovalProcess && hasEquivalencyRequirements)
          return 'Clear substitution provisions with approval process and qualification equivalency requirements.';
        if (hasApprovalProcess)
          return 'Substitution approval process defined, but equivalency requirements could be clearer.';
        if (hasEquivalencyRequirements)
          return 'Substitution equivalency requirements defined, but approval process could be clearer.';
        return 'Basic substitution information provided but lacks specific process details.';
        
      case 'Commitment Requirements':
        if (!extractedInfo.commitment)
          return 'No commitment requirements identified. Consider specifying expected availability.';
        
        const hasSpecificCommitment = /\d+%|\d+\s+hours|full-time|part-time/i.test(
          extractedInfo.commitment
        );
        
        const hasDurationCommitment = /duration|throughout|entire|period of performance/i.test(
          extractedInfo.commitment
        );
        
        if (hasSpecificCommitment && hasDurationCommitment)
          return 'Clear commitment requirements with specific time allocation and duration expectations.';
        if (hasSpecificCommitment)
          return 'Specific time commitment requirements defined, but duration could be clearer.';
        if (hasDurationCommitment)
          return 'Duration commitment requirements defined, but specific time allocation could be clearer.';
        return 'Basic commitment information provided but lacks specific details.';
        
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/managementApproachAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class ManagementApproachAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Management Approach';
    this.requiredElements = ['structure', 'personnel', 'processes', 'oversight'];
    this.evaluationCriteria = [
      {
        name: 'Organizational Structure',
        description: 'Requirements for organizational structure and management hierarchy'
      },
      {
        name: 'Key Personnel',
        description: 'Requirements for key management personnel'
      },
      {
        name: 'Management Processes',
        description: 'Requirements for management processes and procedures'
      },
      {
        name: 'Evaluation Method',
        description: 'How the management approach will be evaluated'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      organizationalStructure: this.extractOrganizationalStructure(sectionText),
      keyPersonnel: this.extractKeyPersonnel(sectionText),
      managementProcesses: this.extractManagementProcesses(sectionText),
      evaluationMethod: this.extractEvaluationMethod(sectionText)
    };
  }
  
  private extractOrganizationalStructure(text: string): string {
    const structureKeywords = [
      'structure', 'organization', 'hierarchy', 'chart', 'team',
      'reporting', 'authority', 'responsibility'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const structureSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, structureKeywords)
    );
    
    return structureSentences.join('. ');
  }
  
  private extractKeyPersonnel(text: string): string {
    const personnelKeywords = [
      'personnel', 'manager', 'director', 'lead', 'supervisor',
      'experience', 'qualification', 'role', 'responsibility'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const personnelSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, personnelKeywords)
    );
    
    return personnelSentences.join('. ');
  }
  
  private extractManagementProcesses(text: string): string {
    const processKeywords = [
      'process', 'procedure', 'methodology', 'approach', 'system',
      'oversight', 'monitor', 'control', 'quality'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const processSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, processKeywords)
    );
    
    return processSentences.join('. ');
  }
  
  private extractEvaluationMethod(text: string): string {
    const evaluationKeywords = [
      'evaluate', 'assess', 'review', 'factor', 'score', 'rating',
      'criterion', 'consideration'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const evaluationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, evaluationKeywords)
    );
    
    return evaluationSentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): number {
    switch (criterion.name) {
      case 'Organizational Structure':
        if (!extractedInfo.organizationalStructure) return 1;
        
        // Check for specific structure elements
        const structureElementCount = this.countKeywordOccurrences(
          extractedInfo.organizationalStructure,
          ['chart', 'diagram', 'hierarchy', 'team', 'department',
           'division', 'unit', 'reporting relationship']
        );
        
        // Check for detail level
        const structureDetail = extractedInfo.organizationalStructure.length;
        
        if (structureElementCount > 2 && structureDetail > 150) return 5;
        if (structureElementCount > 1 && structureDetail > 100) return 4;
        if (structureElementCount > 0 || structureDetail > 100) return 3;
        return 2;
        
      case 'Key Personnel':
        if (!extractedInfo.keyPersonnel) return 1;
        
        // Check for specific roles
        const roleCount = (extractedInfo.keyPersonnel.match(/manager|director|lead|supervisor|executive/gi) || []).length;
        
        // Check for qualification requirements
        const hasQualificationRequirements = /experience|qualification|skill|knowledge|education|certification/i.test(
          extractedInfo.keyPersonnel
        );
        
        if (roleCount > 2 && hasQualificationRequirements) return 5;
        if (roleCount > 0 && hasQualificationRequirements) return 4;
        if (roleCount > 0 || hasQualificationRequirements) return 3;
        return 2;
        
      case 'Management Processes':
        if (!extractedInfo.managementProcesses) return 1;
        
        // Check for specific process types
        const processTypeCount = this.countKeywordOccurrences(
          extractedInfo.managementProcesses,
          ['quality', 'risk', 'schedule', 'performance', 'communication',
           'issue', 'change', 'resource']
        );
        
        // Check for process detail
        const processDetail = extractedInfo.managementProcesses.length;
        
        if (processTypeCount > 3 && processDetail > 150) return 5;
        if (processTypeCount > 1 && processDetail > 100) return 4;
        if (processTypeCount > 0 || processDetail > 100) return 3;
        return 2;
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod) return 1;
        
        // Check for specific evaluation criteria
        const evaluationCriteriaCount = this.countKeywordOccurrences(
          extractedInfo.evaluationMethod,
          ['effectiveness', 'efficiency', 'feasibility', 'adequacy',
           'comprehensiveness', 'reliability']
        );
        
        // Check for evaluation approach
        const hasEvaluationApproach = /weight|factor|score|rating|point|relative importance/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (evaluationCriteriaCount > 2 && hasEvaluationApproach) return 5;
        if (evaluationCriteriaCount > 0 && hasEvaluationApproach) return 4;
        if (evaluationCriteriaCount > 0 || hasEvaluationApproach) return 3;
        return 2;
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): string {
    switch (criterion.name) {
      case 'Organizational Structure':
        if (!extractedInfo.organizationalStructure)
          return 'No organizational structure requirements identified.';
        
        const structureElementCount = this.countKeywordOccurrences(
          extractedInfo.organizationalStructure,
          ['chart', 'diagram', 'hierarchy', 'team', 'department',
           'division', 'unit', 'reporting relationship']
        );
        
        const structureDetail = extractedInfo.organizationalStructure.length;
        
        if (structureElementCount > 2 && structureDetail > 150)
          return 'Comprehensive organizational structure requirements with multiple specific elements and detailed instructions.';
        if (structureElementCount > 1 && structureDetail > 100)
          return 'Good organizational structure requirements with specific elements and some detail.';
        if (structureElementCount > 0)
          return 'Some specific organizational structure elements mentioned but could include more detail.';
        if (structureDetail > 100)
          return 'Detailed organizational structure information provided but specific elements could be clearer.';
        return 'Basic organizational structure information provided but lacks specificity.';
        
      case 'Key Personnel':
        if (!extractedInfo.keyPersonnel)
          return 'No key personnel requirements identified.';
        
        const roleCount = (extractedInfo.keyPersonnel.match(/manager|director|lead|supervisor|executive/gi) || []).length;
        
        const hasQualificationRequirements = /experience|qualification|skill|knowledge|education|certification/i.test(
          extractedInfo.keyPersonnel
        );
        
        if (roleCount > 2 && hasQualificationRequirements)
          return 'Comprehensive key personnel requirements with multiple specific roles and qualification requirements.';
        if (roleCount > 0 && hasQualificationRequirements)
          return 'Good key personnel requirements with specific roles and qualification requirements.';
        if (roleCount > 0)
          return 'Specific management roles mentioned but qualification requirements could be clearer.';
        if (hasQualificationRequirements)
          return 'Management qualification requirements mentioned but specific roles could be clearer.';
        return 'Basic key personnel information provided but lacks specificity.';
        
      case 'Management Processes':
        if (!extractedInfo.managementProcesses)
          return 'No management process requirements identified.';
        
        const processTypeCount = this.countKeywordOccurrences(
          extractedInfo.managementProcesses,
          ['quality', 'risk', 'schedule', 'performance', 'communication',
           'issue', 'change', 'resource']
        );
        
        const processDetail = extractedInfo.managementProcesses.length;
        
        if (processTypeCount > 3 && processDetail > 150)
          return 'Comprehensive management process requirements with multiple specific process types and detailed instructions.';
        if (processTypeCount > 1 && processDetail > 100)
          return 'Good management process requirements with specific process types and some detail.';
        if (processTypeCount > 0)
          return 'Some specific management process types mentioned but could include more detail.';
        if (processDetail > 100)
          return 'Detailed management process information provided but specific types could be clearer.';
        return 'Basic management process information provided but lacks specificity.';
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod)
          return 'No evaluation method for management approach identified.';
        
        const evaluationCriteriaCount = this.countKeywordOccurrences(
          extractedInfo.evaluationMethod,
          ['effectiveness', 'efficiency', 'feasibility', 'adequacy',
           'comprehensiveness', 'reliability']
        );
        
        const hasEvaluationApproach = /weight|factor|score|rating|point|relative importance/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (evaluationCriteriaCount > 2 && hasEvaluationApproach)
          return 'Clear evaluation method with multiple specific criteria and scoring approach for management approach.';
        if (evaluationCriteriaCount > 0 && hasEvaluationApproach)
          return 'Good evaluation method with some specific criteria and scoring approach.';
        if (evaluationCriteriaCount > 0)
          return 'Some specific evaluation criteria mentioned but scoring approach could be clearer.';
        if (hasEvaluationApproach)
          return 'Evaluation scoring approach mentioned but specific criteria could be clearer.';
        return 'Limited evaluation method information provided.';
        
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/pastPerformanceAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class PastPerformanceAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Past Performance';
    this.requiredElements = ['projects', 'references', 'ratings'];
    this.evaluationCriteria = [
      {
        name: 'Project Requirements',
        description: 'Clear requirements for past project information'
      },
      {
        name: 'Relevance Criteria',
        description: 'Criteria for determining relevance of past performance'
      },
      {
        name: 'Reference Requirements',
        description: 'Specificity of reference contact requirements'
      },
      {
        name: 'Evaluation Method',
        description: 'Clear explanation of how past performance will be evaluated'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      projectRequirements: this.extractProjectRequirements(sectionText),
      relevanceCriteria: this.extractRelevanceCriteria(sectionText),
      referenceRequirements: this.extractReferenceRequirements(sectionText),
      evaluationMethod: this.extractEvaluationMethod(sectionText)
    };
  }
  
  private extractProjectRequirements(text: string): string {
    const projectKeywords = [
      'project', 'contract', 'experience', 'work', 'similar', 'previous'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const projectSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, projectKeywords)
    );
    
    return projectSentences.join('. ');
  }
  
  private extractRelevanceCriteria(text: string): string {
    const relevanceKeywords = [
      'relevant', 'similar', 'scope', 'size', 'complexity', 'comparable'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const relevanceSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, relevanceKeywords)
    );
    
    return relevanceSentences.join('. ');
  }
  
  private extractReferenceRequirements(text: string): string {
    const referenceKeywords = [
      'reference', 'contact', 'client', 'customer', 'point of contact', 'POC'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const referenceSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, referenceKeywords)
    );
    
    return referenceSentences.join('. ');
  }
  
  private extractEvaluationMethod(text: string): string {
    const evaluationKeywords = [
      'evaluate', 'assess', 'rate', 'consider', 'factor', 'weight', 'score'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const evaluationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, evaluationKeywords)
    );
    
    return evaluationSentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): number {
    switch (criterion.name) {
      case 'Project Requirements':
        if (!extractedInfo.projectRequirements) return 1;
        
        // Check for specific quantity requirements
        const hasQuantityRequirement = /\d+\s+(?:project|contract|example)/i.test(
          extractedInfo.projectRequirements
        );
        
        // Check for timeframe requirements
        const hasTimeframeRequirement = /\d+\s+(?:year|month|day)|recent|current|ongoing|completed/i.test(
          extractedInfo.projectRequirements
        );
        
        // Check detail level
        const requirementDetail = extractedInfo.projectRequirements.length;
        
        if (hasQuantityRequirement && hasTimeframeRequirement && requirementDetail > 150) return 5;
        if ((hasQuantityRequirement || hasTimeframeRequirement) && requirementDetail > 100) return 4;
        if (hasQuantityRequirement || hasTimeframeRequirement || requirementDetail > 100) return 3;
        return 2;
        
      case 'Relevance Criteria':
        if (!extractedInfo.relevanceCriteria) return 1;
        
        // Check for specific relevance factors
        const relevanceFactorCount = this.countKeywordOccurrences(
          extractedInfo.relevanceCriteria,
          ['scope', 'size', 'complexity', 'dollar value', 'industry', 'sector', 'technology']
        );
        
        if (relevanceFactorCount > 3 && extractedInfo.relevanceCriteria.length > 100) return 5;
        if (relevanceFactorCount > 2) return 4;
        if (relevanceFactorCount > 0) return 3;
        return 2;
        
      case 'Reference Requirements':
        if (!extractedInfo.referenceRequirements) return 1;
        
        // Check for specific reference information requirements
        const hasContactInfo = /name|phone|email|address|title|position/i.test(
          extractedInfo.referenceRequirements
        );
        
        // Check for verification statement
        const hasVerification = /verify|verification|confirm|check|contact|call/i.test(
          extractedInfo.referenceRequirements
        );
        
        if (hasContactInfo && hasVerification) return 5;
        if (hasContactInfo) return 4;
        if (hasVerification || extractedInfo.referenceRequirements.length > 50) return 3;
        return 2;
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod) return 1;
        
        // Check for specific evaluation criteria
        const hasCriteria = /quality|timeliness|cost control|management|customer satisfaction|performance/i.test(
          extractedInfo.evaluationMethod
        );
        
        // Check for rating scale
        const hasRatingScale = /scale|rating|score|excellent|acceptable|marginal|poor|confidence/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (hasCriteria && hasRatingScale) return 5;
        if (hasCriteria || hasRatingScale) return 4;
        if (extractedInfo.evaluationMethod.length > 50) return 3;
        return 2;
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): string {
    switch (criterion.name) {
      case 'Project Requirements':
        if (!extractedInfo.projectRequirements)
          return 'No project requirements identified for past performance.';
        
        const hasQuantityRequirement = /\d+\s+(?:project|contract|example)/i.test(
          extractedInfo.projectRequirements
        );
        
        const hasTimeframeRequirement = /\d+\s+(?:year|month|day)|recent|current|ongoing|completed/i.test(
          extractedInfo.projectRequirements
        );
        
        const requirementDetail = extractedInfo.projectRequirements.length;
        
        if (hasQuantityRequirement && hasTimeframeRequirement && requirementDetail > 150)
          return 'Comprehensive project requirements with specific quantity, timeframe, and detailed information requirements.';
        if ((hasQuantityRequirement || hasTimeframeRequirement) && requirementDetail > 100)
          return 'Good project requirements with either quantity or timeframe specifications and good detail.';
        if (hasQuantityRequirement)
          return 'Project quantity requirements specified but could include more detail on timeframe and content.';
        if (hasTimeframeRequirement)
          return 'Project timeframe requirements specified but could include more detail on quantity and content.';
        if (requirementDetail > 100)
          return 'Detailed project information requirements but lacks specific quantity or timeframe guidance.';
        return 'Basic project requirements provided but lacks specificity.';
        
      case 'Relevance Criteria':
        if (!extractedInfo.relevanceCriteria)
          return 'No relevance criteria identified for evaluating past performance.';
        
        const relevanceFactorCount = this.countKeywordOccurrences(
          extractedInfo.relevanceCriteria,
          ['scope', 'size', 'complexity', 'dollar value', 'industry', 'sector', 'technology']
        );
        
        if (relevanceFactorCount > 3 && extractedInfo.relevanceCriteria.length > 100)
          return 'Comprehensive relevance criteria with multiple specific factors for determining similarity.';
        if (relevanceFactorCount > 2)
          return 'Good relevance criteria with several specific factors identified.';
        if (relevanceFactorCount > 0)
          return 'Basic relevance criteria mentioned but could be more comprehensive.';
        return 'Limited information on how relevance of past performance will be determined.';
        
      case 'Reference Requirements':
        if (!extractedInfo.referenceRequirements)
          return 'No reference requirements identified.';
        
        const hasContactInfo = /name|phone|email|address|title|position/i.test(
          extractedInfo.referenceRequirements
        );
        
        const hasVerification = /verify|verification|confirm|check|contact|call/i.test(
          extractedInfo.referenceRequirements
        );
        
        if (hasContactInfo && hasVerification)
          return 'Comprehensive reference requirements with specific contact information and verification statement.';
        if (hasContactInfo)
          return 'Specific contact information requirements for references provided but verification approach could be clearer.';
        if (hasVerification)
          return 'Reference verification approach mentioned but specific contact information requirements could be clearer.';
        return 'Basic reference information requested but lacks specificity.';
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod)
          return 'No evaluation method identified for past performance.';
        
        const hasCriteria = /quality|timeliness|cost control|management|customer satisfaction|performance/i.test(
          extractedInfo.evaluationMethod
        );
        
        const hasRatingScale = /scale|rating|score|excellent|acceptable|marginal|poor|confidence/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (hasCriteria && hasRatingScale)
          return 'Clear evaluation method with specific criteria and rating scale for past performance.';
        if (hasCriteria)
          return 'Specific evaluation criteria mentioned but rating approach could be clearer.';
        if (hasRatingScale)
          return 'Rating scale provided but specific evaluation criteria could be clearer.';
        return 'Basic evaluation information provided but lacks specificity.';
        
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/periodOfPerformanceAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class PerformanceAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Period of Performance';
    this.requiredElements = ['start_date', 'end_date', 'milestones', 'deadlines'];
    this.evaluationCriteria = [
      {
        name: 'Timeline Clarity',
        description: 'Clarity and specificity of performance timeline'
      },
      {
        name: 'Milestone Definition',
        description: 'Clear definition of project milestones and deliverable dates'
      },
      {
        name: 'Flexibility',
        description: 'Appropriate provisions for timeline adjustments if needed'
      },
      {
        name: 'Alignment with Scope',
        description: 'Appropriate timeframe for the project scope'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      performancePeriod: this.extractPerformancePeriod(sectionText),
      startDate: this.extractStartDate(sectionText),
      endDate: this.extractEndDate(sectionText),
      milestones: this.extractMilestones(sectionText),
      flexibility: this.extractFlexibility(sectionText)
    };
  }
  
  private extractPerformancePeriod(text: string): string {
    const periodKeywords = [
      'period of performance', 'contract period', 'performance period', 
      'duration', 'timeframe', 'period'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const periodSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, periodKeywords)
    );
    
    return periodSentences.join('. ');
  }
  
  private extractStartDate(text: string): string {
    const startKeywords = [
      'start date', 'commence', 'begin', 'effective date', 'start'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const startSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, startKeywords)
    );
    
    return startSentences.join('. ');
  }
  
  private extractEndDate(text: string): string {
    const endKeywords = [
      'end date', 'completion date', 'conclude', 'expire', 'termination'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const endSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, endKeywords)
    );
    
    return endSentences.join('. ');
  }
  
  private extractMilestones(text: string): string {
    const milestoneKeywords = [
      'milestone', 'deliverable date', 'phase', 'schedule', 'deadline', 'due date'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const milestoneSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, milestoneKeywords)
    );
    
    return milestoneSentences.join('. ');
  }
  
  private extractFlexibility(text: string): string {
    const flexibilityKeywords = [
      'extension', 'option', 'adjust', 'modify', 'change', 'flexibility'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const flexibilitySentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, flexibilityKeywords)
    );
    
    return flexibilitySentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
    sectionText: string
  ): number {
    switch (criterion.name) {
      case 'Timeline Clarity':
        // Check if specific dates or durations are provided
        const hasStartDate = /\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}\s+[a-z]+\s+\d{4}|20\d\d/.test(
          extractedInfo.startDate || ''
        );
        
        const hasEndDate = /\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}\s+[a-z]+\s+\d{4}|20\d\d/.test(
          extractedInfo.endDate || ''
        );
        
        const hasDuration = /\d+\s+(?:day|week|month|year)|(?:day|week|month|year)s/.test(
          extractedInfo.performancePeriod || ''
        );
        
        if (hasStartDate && hasEndDate) return 5;
        if ((hasStartDate || hasEndDate) && hasDuration) return 4;
        if (hasStartDate || hasEndDate || hasDuration) return 3;
        return extractedInfo.performancePeriod ? 2 : 1;
        
      case 'Milestone Definition':
        if (!extractedInfo.milestones) return 1;
        
        // Check for specific milestone dates
        const hasMilestoneDates = /\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}\s+[a-z]+\s+\d{4}|20\d\d/.test(
          extractedInfo.milestones
        );
        
        // Check for multiple milestones
        const milestoneCount = (extractedInfo.milestones.match(/milestone|phase|deliverable/gi) || []).length;
        
        if (hasMilestoneDates && milestoneCount > 3) return 5;
        if (hasMilestoneDates && milestoneCount > 1) return 4;
        if (hasMilestoneDates || milestoneCount > 1) return 3;
        return 2;
        
      case 'Flexibility':
        if (!extractedInfo.flexibility) return 2; // Not necessarily bad if no flexibility mentioned
        
        const flexibilityScore = this.countKeywordOccurrences(
          extractedInfo.flexibility,
          ['extension', 'option', 'adjust', 'modify', 'change', 'if needed']
        );
        
        return flexibilityScore > 2 ? 5 :
               (flexibilityScore > 0 ? 4 : 3);
        
      case 'Alignment with Scope':
        // This is harder to evaluate automatically - would need more context
        // Look for references to scope or work volume
        const scopeReferences = this.countKeywordOccurrences(
          sectionText,
          ['scope', 'volume', 'appropriate', 'sufficient', 'adequate']
        );
        
        return scopeReferences > 2 ? 4 : 3; // Default to medium score without more context
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
    sectionText: string
  ): string {
    switch (criterion.name) {
      case 'Timeline Clarity':
        const hasStartDate = /\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}\s+[a-z]+\s+\d{4}|20\d\d/.test(
          extractedInfo.startDate || ''
        );
        
        const hasEndDate = /\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}\s+[a-z]+\s+\d{4}|20\d\d/.test(
          extractedInfo.endDate || ''
        );
        
        const hasDuration = /\d+\s+(?:day|week|month|year)|(?:day|week|month|year)s/.test(
          extractedInfo.performancePeriod || ''
        );
        
        if (hasStartDate && hasEndDate)
          return 'Clear start and end dates are specified with exact dates.';
        if ((hasStartDate || hasEndDate) && hasDuration)
          return 'Performance period is defined with specific duration and at least one fixed date.';
        if (hasStartDate || hasEndDate || hasDuration)
          return 'Some timeline information is provided but could be more specific.';
        if (extractedInfo.performancePeriod)
          return 'Period of performance is mentioned but lacks specific dates or duration.';
        return 'No clear timeline information provided.';
        
      case 'Milestone Definition':
        if (!extractedInfo.milestones)
          return 'No milestone information identified.';
        
        const hasMilestoneDates = /\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}\s+[a-z]+\s+\d{4}|20\d\d/.test(
          extractedInfo.milestones
        );
        
        const milestoneCount = (extractedInfo.milestones.match(/milestone|phase|deliverable/gi) || []).length;
        
        if (hasMilestoneDates && milestoneCount > 3)
          return 'Comprehensive milestone schedule with specific dates for multiple project phases.';
        if (hasMilestoneDates && milestoneCount > 1)
          return 'Multiple milestones with specific dates are identified.';
        if (hasMilestoneDates)
          return 'At least one milestone has a specific date, but more detail would be beneficial.';
        if (milestoneCount > 1)
          return 'Multiple milestones mentioned but without specific dates.';
        return 'Limited milestone information provided.';
        
      case 'Flexibility':
        if (!extractedInfo.flexibility)
          return 'No flexibility provisions identified. Consider adding extension options if appropriate.';
        
        const flexibilityScore = this.countKeywordOccurrences(
          extractedInfo.flexibility,
          ['extension', 'option', 'adjust', 'modify', 'change', 'if needed']
        );
        
        if (flexibilityScore > 2)
          return 'Strong flexibility provisions with multiple options for timeline adjustments if needed.';
        if (flexibilityScore > 0)
          return 'Some flexibility provisions included, which is appropriate.';
        return 'Limited flexibility mentioned but could be enhanced.';
        
      case 'Alignment with Scope':
        // This requires more context than is easily available
        const scopeReferences = this.countKeywordOccurrences(
          sectionText,
          ['scope', 'volume', 'appropriate', 'sufficient', 'adequate']
        );
        
        if (scopeReferences > 2)
          return 'Performance period appears well-aligned with project scope based on explicit references.';
        if (scopeReferences > 0)
          return 'Some consideration of alignment between timeline and scope is evident.';
        return 'No explicit alignment between performance period and project scope is mentioned.';
        
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/priceCostProposalAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class PriceCostProposalAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Price/Cost Proposal';
    this.requiredElements = ['pricing_structure', 'cost_estimation', 'cost_breakdown'];
    this.evaluationCriteria = [
      {
        name: 'Pricing Structure',
        description: 'Clarity of required pricing structure and format'
      },
      {
        name: 'Cost Elements',
        description: 'Comprehensiveness of cost elements to be included'
      },
      {
        name: 'Cost Principles',
        description: 'Alignment with applicable cost principles and regulations'
      },
      {
        name: 'Evaluation Methodology',
        description: 'Clear explanation of how cost proposals will be evaluated'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      pricingStructure: this.extractPricingStructure(sectionText),
      costElements: this.extractCostElements(sectionText),
      costPrinciples: this.extractCostPrinciples(sectionText),
      evaluationMethodology: this.extractEvaluationMethodology(sectionText)
    };
  }
  
  private extractPricingStructure(text: string): string {
    const structureKeywords = [
      'price', 'cost', 'fee', 'structure', 'format', 'schedule', 'proposal'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const structureSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, structureKeywords)
    );
    
    return structureSentences.join('. ');
  }
  
  private extractCostElements(text: string): string {
    const elementKeywords = [
      'direct cost', 'indirect cost', 'overhead', 'G&A', 'labor', 'material',
      'travel', 'equipment', 'subcontract', 'ODC', 'other direct cost'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const elementSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, elementKeywords)
    );
    
    return elementSentences.join('. ');
  }
  
  private extractCostPrinciples(text: string): string {
    const principleKeywords = [
      'principle', 'regulation', 'FAR', 'reasonable', 'allowable', 'allocable',
      'compliance', 'DCAA', 'CAS', 'cost accounting'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const principleSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, principleKeywords)
    );
    
    return principleSentences.join('. ');
  }
  
  private extractEvaluationMethodology(text: string): string {
    const methodologyKeywords = [
      'evaluate', 'assessment', 'analysis', 'review', 'reasonableness',
      'realism', 'comparison', 'best value'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const methodologySentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, methodologyKeywords)
    );
    
    return methodologySentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
    sectionText: string
  ): number {
    switch (criterion.name) {
      case 'Pricing Structure':
        if (!extractedInfo.pricingStructure) return 1;
        
        const hasSpecificFormat = /format|template|form|spreadsheet|table/.test(
          extractedInfo.pricingStructure.toLowerCase()
        );
        
        const structureDetail = extractedInfo.pricingStructure.length;
        
        if (hasSpecificFormat && structureDetail > 150) return 5;
        if (hasSpecificFormat) return 4;
        if (structureDetail > 100) return 3;
        return 2;
        
      case 'Cost Elements':
        if (!extractedInfo.costElements) return 1;
        
        const elementCount = this.countKeywordOccurrences(
          extractedInfo.costElements,
          ['direct', 'indirect', 'overhead', 'G&A', 'labor', 'material',
           'travel', 'equipment', 'subcontract', 'ODC']
        );
        
        return elementCount > 6 ? 5 :
               (elementCount > 4 ? 4 :
               (elementCount > 2 ? 3 : 2));
        
      case 'Cost Principles':
        if (!extractedInfo.costPrinciples) return 1;
        
        const principleCount = this.countKeywordOccurrences(
          extractedInfo.costPrinciples,
          ['principle', 'FAR', 'reasonable', 'allowable', 'allocable',
           'compliance', 'DCAA', 'CAS']
        );
        
        return principleCount > 4 ? 5 :
               (principleCount > 2 ? 4 :
               (principleCount > 0 ? 3 : 2));
        
      case 'Evaluation Methodology':
        if (!extractedInfo.evaluationMethodology) return 1;
        
        const methodologyDetail = extractedInfo.evaluationMethodology.length;
        const hasSpecificApproach = /realism|reasonableness|best value|comparison/.test(
          extractedInfo.evaluationMethodology.toLowerCase()
        );
        
        if (hasSpecificApproach && methodologyDetail > 100) return 5;
        if (hasSpecificApproach) return 4;
        if (methodologyDetail > 50) return 3;
        return 2;
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
    sectionText: string
  ): string {
    switch (criterion.name) {
      case 'Pricing Structure':
        if (!extractedInfo.pricingStructure)
          return 'No clear pricing structure identified.';
        
        const hasSpecificFormat = /format|template|form|spreadsheet|table/.test(
          extractedInfo.pricingStructure.toLowerCase()
        );
        
        const structureDetail = extractedInfo.pricingStructure.length;
        
        if (hasSpecificFormat && structureDetail > 150)
          return 'Comprehensive pricing structure with specific format requirements and detailed guidance.';
        else if (hasSpecificFormat)
          return 'Clear pricing format specified but could include more detailed guidance.';
        else if (structureDetail > 100)
          return 'Detailed pricing guidance provided but specific format could be clearer.';
        else
          return 'Basic pricing information provided but lacks specific structure and format.';
        
      case 'Cost Elements':
        if (!extractedInfo.costElements)
          return 'No clear cost elements identified.';
        
        const elementCount = this.countKeywordOccurrences(
          extractedInfo.costElements,
          ['direct', 'indirect', 'overhead', 'G&A', 'labor', 'material',
           'travel', 'equipment', 'subcontract', 'ODC']
        );
        
        if (elementCount > 6)
          return 'Comprehensive list of cost elements with specific categories and subcategories.';
        else if (elementCount > 4)
          return 'Good coverage of major cost elements with some detail.';
        else if (elementCount > 2)
          return 'Basic cost elements mentioned but could be more comprehensive.';
        else
          return 'Minimal mention of specific cost elements which could lead to inconsistent proposals.';
        
      case 'Cost Principles':
        if (!extractedInfo.costPrinciples)
          return 'No reference to cost principles or regulations.';
        
        const principleCount = this.countKeywordOccurrences(
          extractedInfo.costPrinciples,
          ['principle', 'FAR', 'reasonable', 'allowable', 'allocable',
           'compliance', 'DCAA', 'CAS']
        );
        
        if (principleCount > 4)
          return 'Strong emphasis on cost principles with specific regulatory references.';
        else if (principleCount > 2)
          return 'Good reference to cost principles with some regulatory guidance.';
        else if (principleCount > 0)
          return 'Basic mention of cost principles but lacks specific regulatory references.';
        else
          return 'Limited or no reference to applicable cost principles and regulations.';
        
      case 'Evaluation Methodology':
        if (!extractedInfo.evaluationMethodology)
          return 'No clear methodology for evaluating cost proposals.';
        
        const methodologyDetail = extractedInfo.evaluationMethodology.length;
        const hasSpecificApproach = /realism|reasonableness|best value|comparison/.test(
          extractedInfo.evaluationMethodology.toLowerCase()
        );
        
        if (hasSpecificApproach && methodologyDetail > 100)
          return 'Comprehensive explanation of cost evaluation methodology with specific approaches.';
        else if (hasSpecificApproach)
          return 'Clear cost evaluation approach specified but could include more detail.';
        else if (methodologyDetail > 50)
          return 'Some information on cost evaluation provided but specific approach could be clearer.';
        else
          return 'Limited information on how cost proposals will be evaluated.';
        
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/proposalSubmissionAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class ProposalSubmissionAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Proposal Submission';
    this.requiredElements = ['format', 'method', 'required_documents'];
    this.evaluationCriteria = [
      {
        name: 'Format Instructions',
        description: 'Clarity of proposal format requirements'
      },
      {
        name: 'Submission Method',
        description: 'Clear definition of submission method and deadlines'
      },
      {
        name: 'Required Documents',
        description: 'Comprehensive list of required documents and attachments'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      format: this.extractFormat(sectionText),
      submissionMethod: this.extractSubmissionMethod(sectionText),
      requiredDocuments: this.extractRequiredDocuments(sectionText),
      deadlines: this.extractDeadlines(sectionText)
    };
  }
  
  private extractFormat(text: string): string {
    const formatKeywords = [
      'format', 'layout', 'structure', 'organize', 'page limit', 'font', 'margin'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const formatSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, formatKeywords)
    );
    
    return formatSentences.join('. ');
  }
  
  private extractSubmissionMethod(text: string): string {
    const methodKeywords = [
      'submit', 'submission', 'deliver', 'email', 'portal', 'mail', 'upload'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const methodSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, methodKeywords)
    );
    
    return methodSentences.join('. ');
  }
  
  private extractRequiredDocuments(text: string): string {
    const documentKeywords = [
      'document', 'attachment', 'appendix', 'form', 'certificate', 'submission package'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const documentSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, documentKeywords)
    );
    
    return documentSentences.join('. ');
  }
  
  private extractDeadlines(text: string): string {
    const deadlineKeywords = [
      'deadline', 'due date', 'due by', 'no later than', 'by', 'dated'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const deadlineSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, deadlineKeywords)
    );
    
    return deadlineSentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): number {
    switch (criterion.name) {
      case 'Format Instructions':
        if (!extractedInfo.format) return 1;
        
        const formatSpecificity = this.countKeywordOccurrences(
          extractedInfo.format,
          ['page', 'font', 'margin', 'size', 'number', 'limit', 'section', 'heading']
        );
        
        return formatSpecificity > 5 ? 5 :
               (formatSpecificity > 3 ? 4 :
               (formatSpecificity > 1 ? 3 : 2));
        
      case 'Submission Method':
        if (!extractedInfo.submissionMethod || !extractedInfo.deadlines) return 1;
        
        // Check for specific submission methods
        const hasSpecificMethod = /email|portal|mail|upload|website|platform/.test(
          extractedInfo.submissionMethod.toLowerCase()
        );
        
        // Check for specific deadline
        const hasSpecificDeadline = /\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}\s+[a-z]+\s+\d{4}|20\d\d/.test(
          extractedInfo.deadlines.toLowerCase()
        );
        
        if (hasSpecificMethod && hasSpecificDeadline) return 5;
        if (hasSpecificMethod) return 4;
        if (hasSpecificDeadline) return 3;
        return 2;
        
      case 'Required Documents':
        if (!extractedInfo.requiredDocuments) return 1;
        
        // Count the number of document references
        const documentCount = (extractedInfo.requiredDocuments.match(/document|form|certificate|appendix|attachment/gi) || []).length;
        
        return documentCount > 6 ? 5 :
               (documentCount > 4 ? 4 :
               (documentCount > 2 ? 3 : 2));
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): string {
    switch (criterion.name) {
      case 'Format Instructions':
        if (!extractedInfo.format)
          return 'No clear format instructions identified.';
        
        const formatSpecificity = this.countKeywordOccurrences(
          extractedInfo.format,
          ['page', 'font', 'margin', 'size', 'number', 'limit', 'section', 'heading']
        );
        
        if (formatSpecificity > 5)
          return 'Comprehensive format instructions with specific requirements for layout, structure, and presentation.';
        else if (formatSpecificity > 3)
          return 'Good format instructions with several specific requirements.';
        else if (formatSpecificity > 1)
          return 'Basic format instructions with limited specific requirements.';
        else
          return 'Minimal format instructions that may lead to inconsistent proposal submissions.';
        
      case 'Submission Method':
        if (!extractedInfo.submissionMethod)
          return 'No clear submission method identified.';
        if (!extractedInfo.deadlines)
          return 'No clear submission deadline identified.';
        
        const hasSpecificMethod = /email|portal|mail|upload|website|platform/.test(
          extractedInfo.submissionMethod.toLowerCase()
        );
        
        const hasSpecificDeadline = /\d{1,2}\/\d{1,2}\/\d{2,4}|\d{1,2}\s+[a-z]+\s+\d{4}|20\d\d/.test(
          extractedInfo.deadlines.toLowerCase()
        );
        
        if (hasSpecificMethod && hasSpecificDeadline)
          return 'Clear submission method and deadline specified.';
        else if (hasSpecificMethod)
          return 'Submission method specified but deadline could be clearer.';
        else if (hasSpecificDeadline)
          return 'Deadline specified but submission method could be clearer.';
        return 'Basic submission information provided but lacks specificity.';
        
      case 'Required Documents':
        if (!extractedInfo.requiredDocuments)
          return 'No clear list of required documents identified.';
        
        const documentCount = (extractedInfo.requiredDocuments.match(/document|form|certificate|appendix|attachment/gi) || []).length;
        
        if (documentCount > 6)
          return 'Comprehensive list of required documents with specific requirements.';
        else if (documentCount > 4)
          return 'Good list of required documents with several specific items.';
        else if (documentCount > 2)
          return 'Basic list of required documents with limited specificity.';
        return 'Minimal document requirements that may need clarification.';
        
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/riskAssessmentAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class RiskAssessmentAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Risk Assessment';
    this.requiredElements = ['identification', 'mitigation', 'monitoring', 'analysis'];
    this.evaluationCriteria = [
      {
        name: 'Risk Identification',
        description: 'Requirements for identifying project risks'
      },
      {
        name: 'Risk Mitigation',
        description: 'Requirements for mitigating identified risks'
      },
      {
        name: 'Risk Monitoring',
        description: 'Requirements for ongoing risk monitoring and management'
      },
      {
        name: 'Evaluation Method',
        description: 'How the risk assessment will be evaluated'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      riskIdentification: this.extractRiskIdentification(sectionText),
      riskMitigation: this.extractRiskMitigation(sectionText),
      riskMonitoring: this.extractRiskMonitoring(sectionText),
      evaluationMethod: this.extractEvaluationMethod(sectionText)
    };
  }
  
  private extractRiskIdentification(text: string): string {
    const identificationKeywords = [
      'identify', 'identification', 'assess', 'assessment', 'analyze',
      'analysis', 'risk', 'threat', 'vulnerability'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const identificationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, identificationKeywords)
    );
    
    return identificationSentences.join('. ');
  }
  
  private extractRiskMitigation(text: string): string {
    const mitigationKeywords = [
      'mitigate', 'mitigation', 'reduce', 'reduction', 'manage',
      'management', 'control', 'address', 'respond'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const mitigationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, mitigationKeywords)
    );
    
    return mitigationSentences.join('. ');
  }
  
  private extractRiskMonitoring(text: string): string {
    const monitoringKeywords = [
      'monitor', 'monitoring', 'track', 'tracking', 'report',
      'reporting', 'update', 'review', 'oversight'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const monitoringSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, monitoringKeywords)
    );
    
    return monitoringSentences.join('. ');
  }
  
  private extractEvaluationMethod(text: string): string {
    const evaluationKeywords = [
      'evaluate', 'assess', 'review', 'factor', 'score', 'rating',
      'criterion', 'consideration'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const evaluationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, evaluationKeywords)
    );
    
    return evaluationSentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): number {
    switch (criterion.name) {
      case 'Risk Identification':
        if (!extractedInfo.riskIdentification) return 1;
        
        // Check for specific risk types
        const riskTypeCount = this.countKeywordOccurrences(
          extractedInfo.riskIdentification,
          ['technical', 'schedule', 'cost', 'performance', 'resource',
           'quality', 'management', 'external']
        );
        
        // Check for identification methodology
        const hasMethodology = /method|process|procedure|approach|matrix|register|log/i.test(
          extractedInfo.riskIdentification
        );
        
        if (riskTypeCount > 3 && hasMethodology) return 5;
        if (riskTypeCount > 1 && hasMethodology) return 4;
        if (riskTypeCount > 0 || hasMethodology) return 3;
        return 2;
        
      case 'Risk Mitigation':
        if (!extractedInfo.riskMitigation) return 1;
        
        // Check for specific mitigation approaches
        const mitigationApproachCount = this.countKeywordOccurrences(
          extractedInfo.riskMitigation,
          ['avoid', 'accept', 'transfer', 'mitigate', 'control',
           'contingency', 'plan', 'strategy']
        );
        
        // Check for mitigation detail
        const mitigationDetail = extractedInfo.riskMitigation.length;
        
        if (mitigationApproachCount > 2 && mitigationDetail > 120) return 5;
        if (mitigationApproachCount > 1 && mitigationDetail > 80) return 4;
        if (mitigationApproachCount > 0 || mitigationDetail > 80) return 3;
        return 2;
        
      case 'Risk Monitoring':
        if (!extractedInfo.riskMonitoring) return 1;
        
        // Check for monitoring frequency
        const hasMonitoringFrequency = /continuous|ongoing|regular|periodic|weekly|monthly|quarterly/i.test(
          extractedInfo.riskMonitoring
        );
        
        // Check for monitoring process
        const hasMonitoringProcess = /process|procedure|approach|report|review|meeting|update/i.test(
          extractedInfo.riskMonitoring
        );
        
        if (hasMonitoringFrequency && hasMonitoringProcess) return 5;
        if (hasMonitoringFrequency || hasMonitoringProcess) return 4;
        if (extractedInfo.riskMonitoring.length > 50) return 3;
        return 2;
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod) return 1;
        
        // Check for specific evaluation criteria
        const evaluationCriteriaCount = this.countKeywordOccurrences(
          extractedInfo.evaluationMethod,
          ['thoroughness', 'completeness', 'effectiveness', 'practicality',
           'realism', 'adequacy', 'comprehensiveness']
        );
        
        // Check for evaluation approach
        const hasEvaluationApproach = /weight|factor|score|rating|point|relative importance/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (evaluationCriteriaCount > 1 && hasEvaluationApproach) return 5;
        if (evaluationCriteriaCount > 0 || hasEvaluationApproach) return 4;
        if (extractedInfo.evaluationMethod.length > 50) return 3;
        return 2;
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): string {
    switch (criterion.name) {
      case 'Risk Identification':
        if (!extractedInfo.riskIdentification)
          return 'No risk identification requirements identified.';
        
        const riskTypeCount = this.countKeywordOccurrences(
          extractedInfo.riskIdentification,
          ['technical', 'schedule', 'cost', 'performance', 'resource',
           'quality', 'management', 'external']
        );
        
        const hasMethodology = /method|process|procedure|approach|matrix|register|log/i.test(
          extractedInfo.riskIdentification
        );
        
        if (riskTypeCount > 3 && hasMethodology)
          return 'Comprehensive risk identification requirements with multiple risk types and identification methodology.';
        if (riskTypeCount > 1 && hasMethodology)
          return 'Good risk identification requirements with several risk types and identification methodology.';
        if (riskTypeCount > 0)
          return 'Some specific risk types mentioned but identification methodology could be clearer.';
        if (hasMethodology)
          return 'Risk identification methodology mentioned but specific risk types could be clearer.';
        return 'Basic risk identification information provided but lacks specificity.';
        
      case 'Risk Mitigation':
        if (!extractedInfo.riskMitigation)
          return 'No risk mitigation requirements identified.';
        
        const mitigationApproachCount = this.countKeywordOccurrences(
          extractedInfo.riskMitigation,
          ['avoid', 'accept', 'transfer', 'mitigate', 'control',
           'contingency', 'plan', 'strategy']
        );
        
        const mitigationDetail = extractedInfo.riskMitigation.length;
        
        if (mitigationApproachCount > 2 && mitigationDetail > 120)
          return 'Comprehensive risk mitigation requirements with multiple specific approaches and detailed instructions.';
        if (mitigationApproachCount > 1 && mitigationDetail > 80)
          return 'Good risk mitigation requirements with multiple approaches and some detail.';
        if (mitigationApproachCount > 0)
          return 'Some specific mitigation approaches mentioned but could include more detail.';
        if (mitigationDetail > 80)
          return 'Detailed mitigation information provided but specific approaches could be clearer.';
        return 'Basic risk mitigation information provided but lacks specificity.';
        
      case 'Risk Monitoring':
        if (!extractedInfo.riskMonitoring)
          return 'No risk monitoring requirements identified.';
        
        const hasMonitoringFrequency = /continuous|ongoing|regular|periodic|weekly|monthly|quarterly/i.test(
          extractedInfo.riskMonitoring
        );
        
        const hasMonitoringProcess = /process|procedure|approach|report|review|meeting|update/i.test(
          extractedInfo.riskMonitoring
        );
        
        if (hasMonitoringFrequency && hasMonitoringProcess)
          return 'Clear risk monitoring requirements with monitoring frequency and process specified.';
        if (hasMonitoringFrequency)
          return 'Risk monitoring frequency specified but process could be clearer.';
        if (hasMonitoringProcess)
          return 'Risk monitoring process specified but frequency could be clearer.';
        return 'Basic risk monitoring information provided but lacks specificity.';
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod)
          return 'No evaluation method for risk assessment identified.';
        
        const evaluationCriteriaCount = this.countKeywordOccurrences(
          extractedInfo.evaluationMethod,
          ['thoroughness', 'completeness', 'effectiveness', 'practicality',
           'realism', 'adequacy', 'comprehensiveness']
        );
        
        const hasEvaluationApproach = /weight|factor|score|rating|point|relative importance/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (evaluationCriteriaCount > 1 && hasEvaluationApproach)
          return 'Clear evaluation method with specific criteria and scoring approach for risk assessment.';
        if (evaluationCriteriaCount > 0)
          return 'Some specific evaluation criteria mentioned but scoring approach could be clearer.';
        if (hasEvaluationApproach)
          return 'Evaluation scoring approach mentioned but specific criteria could be clearer.';
        return 'Limited evaluation method information provided.';
        
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/sowAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class SOWAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Statement of Work';
    this.requiredElements = ['tasks', 'deliverables', 'performance_standards'];
    this.evaluationCriteria = [
      {
        name: 'Task Clarity',
        description: 'Clarity and specificity of required tasks'
      },
      {
        name: 'Deliverables Definition',
        description: 'Clear definition of expected deliverables'
      },
      {
        name: 'Performance Standards',
        description: 'Specificity of performance standards and metrics'
      },
      {
        name: 'Technical Requirements',
        description: 'Clarity of technical requirements and specifications'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      tasks: this.extractTasks(sectionText),
      deliverables: this.extractDeliverables(sectionText),
      performanceStandards: this.extractPerformanceStandards(sectionText),
      technicalRequirements: this.extractTechnicalRequirements(sectionText)
    };
  }
  
  private extractTasks(text: string): string {
    const taskKeywords = [
      'task', 'activity', 'perform', 'conduct', 'execute', 'responsible for'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const taskSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, taskKeywords)
    );
    
    return taskSentences.join('. ');
  }
  
  private extractDeliverables(text: string): string {
    const deliverableKeywords = [
      'deliverable', 'deliver', 'provide', 'submission', 'output', 'report'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const deliverableSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, deliverableKeywords)
    );
    
    return deliverableSentences.join('. ');
  }
  
  private extractPerformanceStandards(text: string): string {
    const standardKeywords = [
      'standard', 'metric', 'measure', 'performance', 'quality', 'acceptance criteria'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const standardSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, standardKeywords)
    );
    
    return standardSentences.join('. ');
  }
  
  private extractTechnicalRequirements(text: string): string {
    const techKeywords = [
      'technical', 'specification', 'requirement', 'technology', 'system', 'architecture'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const techSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, techKeywords)
    );
    
    return techSentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): number {
    switch (criterion.name) {
      case 'Task Clarity':
        if (!extractedInfo.tasks) return 1;
        return extractedInfo.tasks.length > 200 ? 5 : 
               (extractedInfo.tasks.length > 100 ? 4 : 3);
               
      case 'Deliverables Definition':
        if (!extractedInfo.deliverables) return 1;
        return extractedInfo.deliverables.length > 150 ? 5 : 
               (extractedInfo.deliverables.length > 80 ? 4 : 3);
               
      case 'Performance Standards':
        if (!extractedInfo.performanceStandards) return 1;
        return extractedInfo.performanceStandards.length > 100 ? 5 : 
               (extractedInfo.performanceStandards.length > 50 ? 4 : 3);
               
      case 'Technical Requirements':
        if (!extractedInfo.technicalRequirements) return 1;
        return extractedInfo.technicalRequirements.length > 120 ? 5 : 
               (extractedInfo.technicalRequirements.length > 60 ? 4 : 3);
               
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): string {
    switch (criterion.name) {
      case 'Task Clarity':
        if (!extractedInfo.tasks)
          return 'No clear tasks identified.';
        return extractedInfo.tasks.length > 200 ?
          'Tasks are clearly defined with specific responsibilities.' :
          'Tasks are present but could benefit from more detailed descriptions.';
          
      case 'Deliverables Definition':
        if (!extractedInfo.deliverables)
          return 'No clear deliverables identified.';
        return extractedInfo.deliverables.length > 150 ?
          'Deliverables are well-defined with clear expectations.' :
          'Deliverables are mentioned but specifications could be more detailed.';
          
      case 'Performance Standards':
        if (!extractedInfo.performanceStandards)
          return 'No performance standards identified.';
        return extractedInfo.performanceStandards.length > 100 ?
          'Clear performance standards with specific metrics provided.' :
          'Some performance standards mentioned but metrics could be more specific.';
          
      case 'Technical Requirements':
        if (!extractedInfo.technicalRequirements)
          return 'No technical requirements identified.';
        return extractedInfo.technicalRequirements.length > 120 ?
          'Technical requirements are clearly specified.' :
          'Technical requirements are mentioned but could be more comprehensive.';
          
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/subcontractingPlanAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class SubcontractingPlanAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Subcontracting Plan';
    this.requiredElements = ['goals', 'compliance', 'reporting'];
    this.evaluationCriteria = [
      {
        name: 'Goal Requirements',
        description: 'Clear requirements for small business subcontracting goals'
      },
      {
        name: 'Plan Elements',
        description: 'Required elements of the subcontracting plan'
      },
      {
        name: 'Reporting Requirements',
        description: 'Clear requirements for subcontracting reporting'
      },
      {
        name: 'Evaluation Method',
        description: 'Clear explanation of how subcontracting plans will be evaluated'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      goalRequirements: this.extractGoalRequirements(sectionText),
      planElements: this.extractPlanElements(sectionText),
      reportingRequirements: this.extractReportingRequirements(sectionText),
      evaluationMethod: this.extractEvaluationMethod(sectionText)
    };
  }
  
  private extractGoalRequirements(text: string): string {
    const goalKeywords = [
      'goal', 'target', 'percentage', 'small business', 'woman-owned', 
      'veteran', 'minority', 'disadvantaged', 'WOSB', 'VOSB', 'SDVOSB', 'HUBZone'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const goalSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, goalKeywords)
    );
    
    return goalSentences.join('. ');
  }
  
  private extractPlanElements(text: string): string {
    const planKeywords = [
      'plan', 'element', 'include', 'submit', 'provide', 'describe',
      'identify', 'detail'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const planSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, planKeywords)
    );
    
    return planSentences.join('. ');
  }
  
  private extractReportingRequirements(text: string): string {
    const reportingKeywords = [
      'report', 'submit', 'ISR', 'SSR', 'Individual Subcontracting Report',
      'Summary Subcontracting Report', 'eSRS'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const reportingSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, reportingKeywords)
    );
    
    return reportingSentences.join('. ');
  }
  
  private extractEvaluationMethod(text: string): string {
    const evaluationKeywords = [
      'evaluate', 'assess', 'review', 'factor', 'consider', 'acceptable',
      'evaluation'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const evaluationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, evaluationKeywords)
    );
    
    return evaluationSentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): number {
    switch (criterion.name) {
      case 'Goal Requirements':
        if (!extractedInfo.goalRequirements) return 1;
        
        // Check for specific percentage goals
        const hasPercentageGoals = /\d+\s*%/.test(extractedInfo.goalRequirements);
        
        // Check for specific small business categories
        const sbCategoryCount = this.countKeywordOccurrences(
          extractedInfo.goalRequirements,
          ['small business', 'woman-owned', 'veteran', 'minority', 'disadvantaged', 
           'WOSB', 'VOSB', 'SDVOSB', 'HUBZone']
        );
        
        if (hasPercentageGoals && sbCategoryCount > 3) return 5;
        if (hasPercentageGoals && sbCategoryCount > 1) return 4;
        if (hasPercentageGoals || sbCategoryCount > 2) return 3;
        return 2;
        
      case 'Plan Elements':
        if (!extractedInfo.planElements) return 1;
        
        // Check for specific plan requirements
        const planElementCount = this.countKeywordOccurrences(
          extractedInfo.planElements,
          ['description', 'identify', 'submit', 'provide', 'include', 'methodology']
        );
        
        // Check for detail level
        const planDetail = extractedInfo.planElements.length;
        
        if (planElementCount > 4 && planDetail > 150) return 5;
        if (planElementCount > 2 && planDetail > 100) return 4;
        if (planElementCount > 1 || planDetail > 100) return 3;
        return 2;
        
      case 'Reporting Requirements':
        if (!extractedInfo.reportingRequirements) return 1;
        
        // Check for specific reporting requirements
        const hasSpecificReports = /ISR|SSR|Individual Subcontracting Report|Summary Subcontracting Report|eSRS/i.test(
          extractedInfo.reportingRequirements
        );
        
        // Check for frequency requirements
        const hasFrequency = /monthly|quarterly|semi-annual|annual|bi-annual/i.test(
          extractedInfo.reportingRequirements
        );
        
        if (hasSpecificReports && hasFrequency) return 5;
        if (hasSpecificReports || hasFrequency) return 4;
        if (extractedInfo.reportingRequirements.length > 50) return 3;
        return 2;
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod) return 1;
        
        // Check for specific evaluation criteria
        const hasEvaluationCriteria = /factor|weight|consider|score|rating/i.test(
          extractedInfo.evaluationMethod
        );
        
        // Check if compliance is mentioned
        const hasComplianceMention = /comply|compliance|requirement|FAR/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (hasEvaluationCriteria && hasComplianceMention) return 5;
        if (hasEvaluationCriteria || hasComplianceMention) return 4;
        if (extractedInfo.evaluationMethod.length > 50) return 3;
        return 2;
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): string {
    switch (criterion.name) {
      case 'Goal Requirements':
        if (!extractedInfo.goalRequirements)
          return 'No small business goal requirements identified.';
        
        const hasPercentageGoals = /\d+\s*%/.test(extractedInfo.goalRequirements);
        
        const sbCategoryCount = this.countKeywordOccurrences(
          extractedInfo.goalRequirements,
          ['small business', 'woman-owned', 'veteran', 'minority', 'disadvantaged', 
           'WOSB', 'VOSB', 'SDVOSB', 'HUBZone']
        );
        
        if (hasPercentageGoals && sbCategoryCount > 3)
          return 'Comprehensive small business goal requirements with specific percentages for multiple categories.';
        if (hasPercentageGoals && sbCategoryCount > 1)
          return 'Good small business goal requirements with specific percentages for some categories.';
        if (hasPercentageGoals)
          return 'Percentage goals provided but could include more specific small business categories.';
        if (sbCategoryCount > 2)
          return 'Multiple small business categories identified but specific percentage goals could be clearer.';
        return 'Limited small business goal information provided.';
        
      case 'Plan Elements':
        if (!extractedInfo.planElements)
          return 'No subcontracting plan element requirements identified.';
        
        const planElementCount = this.countKeywordOccurrences(
          extractedInfo.planElements,
          ['description', 'identify', 'submit', 'provide', 'include', 'methodology']
        );
        
        const planDetail = extractedInfo.planElements.length;
        
        if (planElementCount > 4 && planDetail > 150)
          return 'Comprehensive requirements for subcontracting plan elements with detailed instructions.';
        if (planElementCount > 2 && planDetail > 100)
          return 'Good requirements for plan elements with several specific requirements.';
        if (planElementCount > 1)
          return 'Some specific plan element requirements mentioned but could be more comprehensive.';
        if (planDetail > 100)
          return 'Detailed plan information required but specific elements could be clearer.';
        return 'Basic plan element information provided but lacks specificity.';
        
      case 'Reporting Requirements':
        if (!extractedInfo.reportingRequirements)
          return 'No subcontracting reporting requirements identified.';
        
        const hasSpecificReports = /ISR|SSR|Individual Subcontracting Report|Summary Subcontracting Report|eSRS/i.test(
          extractedInfo.reportingRequirements
        );
        
        const hasFrequency = /monthly|quarterly|semi-annual|annual|bi-annual/i.test(
          extractedInfo.reportingRequirements
        );
        
        if (hasSpecificReports && hasFrequency)
          return 'Clear reporting requirements with specific report types and submission frequency.';
        if (hasSpecificReports)
          return 'Specific report types identified but submission frequency could be clearer.';
        if (hasFrequency)
          return 'Reporting frequency specified but report types could be clearer.';
        return 'Basic reporting information provided but lacks specificity.';
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod)
          return 'No evaluation method for subcontracting plans identified.';
        
        const hasEvaluationCriteria = /factor|weight|consider|score|rating/i.test(
          extractedInfo.evaluationMethod
        );
        
        const hasComplianceMention = /comply|compliance|requirement|FAR/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (hasEvaluationCriteria && hasComplianceMention)
          return 'Clear evaluation method for subcontracting plans with specific criteria and compliance requirements.';
        if (hasEvaluationCriteria)
          return 'Evaluation criteria specified but compliance requirements could be clearer.';
        if (hasComplianceMention)
          return 'Compliance requirements mentioned but specific evaluation criteria could be clearer.';
        return 'Basic evaluation information provided but lacks specificity.';
        
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/supplyChainRiskAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class SupplyChainRiskAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Supply Chain Risk Assessment';
    this.requiredElements = ['risk_identification', 'risk_mitigation', 'vendor_requirements'];
    this.evaluationCriteria = [
      {
        name: 'Risk Identification',
        description: 'Requirements for identifying supply chain risks'
      },
      {
        name: 'Risk Mitigation',
        description: 'Required approaches for mitigating identified risks'
      },
      {
        name: 'Vendor Requirements',
        description: 'Specific requirements for vendor risk management'
      },
      {
        name: 'Evaluation Method',
        description: 'How supply chain risk assessment will be evaluated'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      riskIdentification: this.extractRiskIdentification(sectionText),
      riskMitigation: this.extractRiskMitigation(sectionText),
      vendorRequirements: this.extractVendorRequirements(sectionText),
      evaluationMethod: this.extractEvaluationMethod(sectionText)
    };
  }
  
  private extractRiskIdentification(text: string): string {
    const identificationKeywords = [
      'identify', 'identification', 'assess', 'assessment', 'analyze',
      'analysis', 'risk', 'threat', 'vulnerability'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const identificationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, identificationKeywords)
    );
    
    return identificationSentences.join('. ');
  }
  
  private extractRiskMitigation(text: string): string {
    const mitigationKeywords = [
      'mitigate', 'mitigation', 'reduce', 'reduction', 'manage',
      'management', 'control', 'address', 'respond'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const mitigationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, mitigationKeywords)
    );
    
    return mitigationSentences.join('. ');
  }
  
  private extractVendorRequirements(text: string): string {
    const vendorKeywords = [
      'vendor', 'supplier', 'provider', 'third-party', 'third party',
      'subcontractor', 'partner'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const vendorSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, vendorKeywords)
    );
    
    return vendorSentences.join('. ');
  }
  
  private extractEvaluationMethod(text: string): string {
    const evaluationKeywords = [
      'evaluate', 'assess', 'review', 'factor', 'score', 'rating',
      'consider', 'acceptable'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const evaluationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, evaluationKeywords)
    );
    
    return evaluationSentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
  ): number {
    switch (criterion.name) {
      case 'Risk Identification':
        if (!extractedInfo.riskIdentification) return 1;
        
        // Check for specific risk types
        const riskTypeCount = this.countKeywordOccurrences(
          extractedInfo.riskIdentification,
          ['counterfeit', 'foreign ownership', 'compromise', 'tamper',
           'disruption', 'quality', 'delivery', 'natural disaster']
        );
        
        // Check for identification methodology
        const hasMethodology = /method|process|procedure|approach|framework|SCRM|NIST/i.test(
          extractedInfo.riskIdentification
        );
        
        if (riskTypeCount > 2 && hasMethodology) return 5;
        if (riskTypeCount > 0 && hasMethodology) return 4;
        if (riskTypeCount > 0 || hasMethodology) return 3;
        return 2;
        
      case 'Risk Mitigation':
        if (!extractedInfo.riskMitigation) return 1;
        
        // Check for specific mitigation approaches
        const mitigationApproachCount = this.countKeywordOccurrences(
          extractedInfo.riskMitigation,
          ['avoid', 'accept', 'transfer', 'reduce', 'control',
           'monitor', 'contingency', 'plan', 'strategy']
        );
        
        // Check for mitigation detail
        const mitigationDetail = extractedInfo.riskMitigation.length;
        
        if (mitigationApproachCount > 2 && mitigationDetail > 100) return 5;
        if (mitigationApproachCount > 1) return 4;
        if (mitigationApproachCount > 0 || mitigationDetail > 50) return 3;
        return 2;
        
      case 'Vendor Requirements':
        if (!extractedInfo.vendorRequirements) return 1;
        
        // Check for specific vendor assessment requirements
        const vendorAssessmentCount = this.countKeywordOccurrences(
          extractedInfo.vendorRequirements,
          ['assessment', 'questionnaire', 'audit', 'certification',
           'verification', 'documentation', 'disclosure']
        );
        
        // Check for ongoing monitoring
        const hasOngoingMonitoring = /ongoing|continuous|periodic|monitor|regular/i.test(
          extractedInfo.vendorRequirements
        );
        
        if (vendorAssessmentCount > 2 && hasOngoingMonitoring) return 5;
        if (vendorAssessmentCount > 0 && hasOngoingMonitoring) return 4;
        if (vendorAssessmentCount > 0 || hasOngoingMonitoring) return 3;
        return 2;
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod) return 1;
        
        // Check for evaluation criteria
        const hasEvaluationCriteria = /criteria|factor|score|rating|acceptable|adequate/i.test(
          extractedInfo.evaluationMethod
        );
        
        // Check for methodology reference
        const hasMethodologyReference = /method|process|procedure|framework|NIST|approach/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (hasEvaluationCriteria && hasMethodologyReference) return 5;
        if (hasEvaluationCriteria || hasMethodologyReference) return 4;
        if (extractedInfo.evaluationMethod.length > 50) return 3;
        return 2;
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>,
  ): string {
    switch (criterion.name) {
      case 'Risk Identification':
        if (!extractedInfo.riskIdentification)
          return 'No supply chain risk identification requirements identified.';
        
        const riskTypeCount = this.countKeywordOccurrences(
          extractedInfo.riskIdentification,
          ['counterfeit', 'foreign ownership', 'compromise', 'tamper',
           'disruption', 'quality', 'delivery', 'natural disaster']
        );
        
        const hasMethodology = /method|process|procedure|approach|framework|SCRM|NIST/i.test(
          extractedInfo.riskIdentification
        );
        
        if (riskTypeCount > 2 && hasMethodology)
          return 'Comprehensive risk identification requirements with specific risk types and methodology.';
        if (riskTypeCount > 0 && hasMethodology)
          return 'Good risk identification requirements with methodology and some risk types.';
        if (riskTypeCount > 0)
          return 'Specific risk types mentioned but identification methodology could be clearer.';
        if (hasMethodology)
          return 'Risk identification methodology mentioned but specific risk types could be clearer.';
        return 'Limited risk identification information provided.';
        
      case 'Risk Mitigation':
        if (!extractedInfo.riskMitigation)
          return 'No risk mitigation requirements identified.';
        
        const mitigationApproachCount = this.countKeywordOccurrences(
          extractedInfo.riskMitigation,
          ['avoid', 'accept', 'transfer', 'reduce', 'control',
           'monitor', 'contingency', 'plan', 'strategy']
        );
        
        const mitigationDetail = extractedInfo.riskMitigation.length;
        
        if (mitigationApproachCount > 2 && mitigationDetail > 100)
          return 'Comprehensive risk mitigation requirements with multiple specific approaches.';
        if (mitigationApproachCount > 1)
          return 'Multiple risk mitigation approaches specified.';
        if (mitigationApproachCount > 0)
          return 'Some risk mitigation approach mentioned but could be more comprehensive.';
        if (mitigationDetail > 50)
          return 'Risk mitigation mentioned but specific approaches could be clearer.';
        return 'Limited risk mitigation information provided.';
        
      case 'Vendor Requirements':
        if (!extractedInfo.vendorRequirements)
          return 'No vendor risk management requirements identified.';
        
        const vendorAssessmentCount = this.countKeywordOccurrences(
          extractedInfo.vendorRequirements,
          ['assessment', 'questionnaire', 'audit', 'certification',
           'verification', 'documentation', 'disclosure']
        );
        
        const hasOngoingMonitoring = /ongoing|continuous|periodic|monitor|regular/i.test(
          extractedInfo.vendorRequirements
        );
        
        if (vendorAssessmentCount > 2 && hasOngoingMonitoring)
          return 'Comprehensive vendor risk management requirements with specific assessment methods and ongoing monitoring.';
        if (vendorAssessmentCount > 0 && hasOngoingMonitoring)
          return 'Good vendor risk management requirements with assessment and monitoring.';
        if (vendorAssessmentCount > 0)
          return 'Vendor assessment requirements mentioned but ongoing monitoring could be clearer.';
        if (hasOngoingMonitoring)
          return 'Vendor monitoring mentioned but specific assessment methods could be clearer.';
        return 'Limited vendor risk management information provided.';
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod)
          return 'No evaluation method for supply chain risk assessment identified.';
        
        const hasEvaluationCriteria = /criteria|factor|score|rating|acceptable|adequate/i.test(
          extractedInfo.evaluationMethod
        );
        
        const hasMethodologyReference = /method|process|procedure|framework|NIST|approach/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (hasEvaluationCriteria && hasMethodologyReference)
          return 'Clear evaluation method with specific criteria and methodology for supply chain risk assessment.';
        if (hasEvaluationCriteria)
          return 'Evaluation criteria specified but methodology could be clearer.';
        if (hasMethodologyReference)
          return 'Evaluation methodology referenced but specific criteria could be clearer.';
        return 'Limited evaluation method information provided.';
        
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/analyzers/technicalApproachAnalyzer.ts">
import { SectionAnalyzer } from './baseAnalyzer';

export class TechnicalApproachAnalyzer extends SectionAnalyzer {
  constructor() {
    super();
    this.sectionName = 'Technical Approach';
    this.requiredElements = ['methodology', 'innovation', 'requirements', 'understanding'];
    this.evaluationCriteria = [
      {
        name: 'Methodology Requirements',
        description: 'Requirements for technical methodology or approach'
      },
      {
        name: 'Innovation Emphasis',
        description: 'Emphasis on innovative approaches or solutions'
      },
      {
        name: 'Requirement Compliance',
        description: 'Requirements for demonstrating compliance with technical specifications'
      },
      {
        name: 'Evaluation Method',
        description: 'How the technical approach will be evaluated'
      }
    ];
  }
  
  protected extractInformation(sectionText: string): Record<string, string> {
    return {
      methodologyRequirements: this.extractMethodologyRequirements(sectionText),
      innovationEmphasis: this.extractInnovationEmphasis(sectionText),
      requirementCompliance: this.extractRequirementCompliance(sectionText),
      evaluationMethod: this.extractEvaluationMethod(sectionText)
    };
  }
  
  private extractMethodologyRequirements(text: string): string {
    const methodologyKeywords = [
      'methodology', 'approach', 'method', 'process', 'procedure',
      'technique', 'plan', 'strategy'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const methodologySentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, methodologyKeywords)
    );
    
    return methodologySentences.join('. ');
  }
  
  private extractInnovationEmphasis(text: string): string {
    const innovationKeywords = [
      'innovation', 'innovative', 'novel', 'creative', 'unique',
      'cutting-edge', 'state-of-the-art', 'new', 'advanced'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const innovationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, innovationKeywords)
    );
    
    return innovationSentences.join('. ');
  }
  
  private extractRequirementCompliance(text: string): string {
    const complianceKeywords = [
      'requirement', 'specification', 'comply', 'conformance', 'meet',
      'satisfy', 'address', 'demonstrate'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const complianceSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, complianceKeywords)
    );
    
    return complianceSentences.join('. ');
  }
  
  private extractEvaluationMethod(text: string): string {
    const evaluationKeywords = [
      'evaluate', 'assess', 'review', 'factor', 'score', 'rating',
      'criterion', 'consideration'
    ];
    
    const sentences = text.split(/[.!?]+/);
    const evaluationSentences = sentences.filter(sentence => 
      this.containsKeywords(sentence, evaluationKeywords)
    );
    
    return evaluationSentences.join('. ');
  }
  
  protected evaluateCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): number {
    switch (criterion.name) {
      case 'Methodology Requirements':
        if (!extractedInfo.methodologyRequirements) return 1;
        
        // Check for specific methodological elements
        const methodElementCount = this.countKeywordOccurrences(
          extractedInfo.methodologyRequirements,
          ['development', 'analysis', 'design', 'implementation', 'testing',
           'integration', 'deployment', 'maintenance']
        );
        
        // Check for detail level
        const methodDetail = extractedInfo.methodologyRequirements.length;
        
        if (methodElementCount > 3 && methodDetail > 150) return 5;
        if (methodElementCount > 1 && methodDetail > 100) return 4;
        if (methodElementCount > 0 || methodDetail > 100) return 3;
        return 2;
        
      case 'Innovation Emphasis':
        if (!extractedInfo.innovationEmphasis) return 2; // Not always emphasized
        
        // Check for innovation importance
        const innovationImportance = this.countKeywordOccurrences(
          extractedInfo.innovationEmphasis,
          ['encourage', 'emphasize', 'value', 'seek', 'looking for',
           'important', 'priority', 'advantage']
        );
        
        // Check for specific areas for innovation
        const innovationAreaCount = this.countKeywordOccurrences(
          extractedInfo.innovationEmphasis,
          ['technology', 'process', 'solution', 'approach', 'efficiency',
           'cost', 'performance', 'quality']
        );
        
        if (innovationImportance > 1 && innovationAreaCount > 1) return 5;
        if (innovationImportance > 0 && innovationAreaCount > 0) return 4;
        if (innovationImportance > 0 || innovationAreaCount > 0) return 3;
        return 2;
        
      case 'Requirement Compliance':
        if (!extractedInfo.requirementCompliance) return 1;
        
        // Check for reference to specific requirements
        const specificRequirementReference = /specification|SOW|Statement of Work|technical requirement|performance requirement/i.test(
          extractedInfo.requirementCompliance
        );
        
        // Check for demonstration method
        const hasComplianceDemonstration = /demonstrate|show|prove|evidence|explanation|description|narrative/i.test(
          extractedInfo.requirementCompliance
        );
        
        if (specificRequirementReference && hasComplianceDemonstration) return 5;
        if (specificRequirementReference || hasComplianceDemonstration) return 4;
        if (extractedInfo.requirementCompliance.length > 80) return 3;
        return 2;
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod) return 1;
        
        // Check for specific evaluation criteria
        const evaluationCriteriaCount = this.countKeywordOccurrences(
          extractedInfo.evaluationMethod,
          ['feasibility', 'effectiveness', 'efficiency', 'reliability',
           'scalability', 'maintainability', 'innovation']
        );
        
        // Check for evaluation approach
        const hasEvaluationApproach = /weight|factor|score|rating|point|relative importance/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (evaluationCriteriaCount > 2 && hasEvaluationApproach) return 5;
        if (evaluationCriteriaCount > 0 && hasEvaluationApproach) return 4;
        if (evaluationCriteriaCount > 0 || hasEvaluationApproach) return 3;
        return 2;
        
      default:
        return 3;
    }
  }
  
  protected getCommentsForCriterion(
    criterion: { name: string; description: string },
    extractedInfo: Record<string, string>
  ): string {
    switch (criterion.name) {
      case 'Methodology Requirements':
        if (!extractedInfo.methodologyRequirements)
          return 'No technical methodology requirements identified.';
        
        const methodElementCount = this.countKeywordOccurrences(
          extractedInfo.methodologyRequirements,
          ['development', 'analysis', 'design', 'implementation', 'testing',
           'integration', 'deployment', 'maintenance']
        );
        
        const methodDetail = extractedInfo.methodologyRequirements.length;
        
        if (methodElementCount > 3 && methodDetail > 150)
          return 'Comprehensive methodology requirements with multiple specific elements and detailed instructions.';
        if (methodElementCount > 1 && methodDetail > 100)
          return 'Good methodology requirements with specific elements and some detail.';
        if (methodElementCount > 0)
          return 'Some specific methodological elements mentioned but could include more detail.';
        if (methodDetail > 100)
          return 'Detailed methodology information provided but specific elements could be clearer.';
        return 'Basic methodology information provided but lacks specificity.';
        
      case 'Innovation Emphasis':
        if (!extractedInfo.innovationEmphasis)
          return 'No emphasis on innovation identified.';
        
        const innovationImportance = this.countKeywordOccurrences(
          extractedInfo.innovationEmphasis,
          ['encourage', 'emphasize', 'value', 'seek', 'looking for',
           'important', 'priority', 'advantage']
        );
        
        const innovationAreaCount = this.countKeywordOccurrences(
          extractedInfo.innovationEmphasis,
          ['technology', 'process', 'solution', 'approach', 'efficiency',
           'cost', 'performance', 'quality']
        );
        
        if (innovationImportance > 1 && innovationAreaCount > 1)
          return 'Strong emphasis on innovation with clear importance and specific areas for innovative approaches.';
        if (innovationImportance > 0 && innovationAreaCount > 0)
          return 'Good emphasis on innovation with some indication of importance and target areas.';
        if (innovationImportance > 0)
          return 'Some emphasis on the importance of innovation but target areas could be clearer.';
        if (innovationAreaCount > 0)
          return 'Some mention of areas for innovation but importance could be emphasized more.';
        return 'Limited innovation emphasis information provided.';
        
      case 'Requirement Compliance':
        if (!extractedInfo.requirementCompliance)
          return 'No requirement compliance information identified.';
        
        const specificRequirementReference = /specification|SOW|Statement of Work|technical requirement|performance requirement/i.test(
          extractedInfo.requirementCompliance
        );
        
        const hasComplianceDemonstration = /demonstrate|show|prove|evidence|explanation|description|narrative/i.test(
          extractedInfo.requirementCompliance
        );
        
        if (specificRequirementReference && hasComplianceDemonstration)
          return 'Clear requirement compliance instructions with specific requirements referenced and demonstration method.';
        if (specificRequirementReference)
          return 'Specific requirements referenced but demonstration method could be clearer.';
        if (hasComplianceDemonstration)
          return 'Compliance demonstration method specified but reference to specific requirements could be clearer.';
        return 'Basic compliance information provided but lacks specificity.';
        
      case 'Evaluation Method':
        if (!extractedInfo.evaluationMethod)
          return 'No evaluation method for technical approach identified.';
        
        const evaluationCriteriaCount = this.countKeywordOccurrences(
          extractedInfo.evaluationMethod,
          ['feasibility', 'effectiveness', 'efficiency', 'reliability',
           'scalability', 'maintainability', 'innovation']
        );
        
        const hasEvaluationApproach = /weight|factor|score|rating|point|relative importance/i.test(
          extractedInfo.evaluationMethod
        );
        
        if (evaluationCriteriaCount > 2 && hasEvaluationApproach)
          return 'Clear evaluation method with multiple specific criteria and scoring approach.';
        if (evaluationCriteriaCount > 0 && hasEvaluationApproach)
          return 'Good evaluation method with some specific criteria and scoring approach.';
        if (evaluationCriteriaCount > 0)
          return 'Some specific evaluation criteria mentioned but scoring approach could be clearer.';
        if (hasEvaluationApproach)
          return 'Evaluation scoring approach mentioned but specific criteria could be clearer.';
        return 'Limited evaluation method information provided.';
        
      default:
        return 'General evaluation.';
    }
  }
}
</file>

<file path="src/app/lib/fileProcessor.ts">
import { RFPDocument, RFPSection } from '@/app/types';

// These imports would need to be installed in the project
// npm install pdf-parse mammoth docx

interface FileProcessorResult {
  document: RFPDocument;
  error?: string;
}

/**
 * Process uploaded RFP document files and extract sections
 */
export class FileProcessor {
  /**
   * Process a file and extract RFP sections
   * @param file File object to process
   * @returns Extracted RFP document with sections
   */
  static async processFile(file: File): Promise<FileProcessorResult> {
    try {
      const fileType = this.getFileType(file);
      let text = '';
      
      switch (fileType) {
        case 'pdf':
          text = await this.processPdf(file);
          break;
        case 'docx':
          text = await this.processDocx(file);
          break;
        case 'doc':
          text = await this.processDoc();
          break;
        case 'txt':
          text = await this.processTxt(file);
          break;
        default:
          return {
            document: {},
            error: 'Unsupported file type. Please upload PDF, DOCX, DOC, or TXT files.'
          };
      }
      
      // Extract sections from the text
      const document = this.extractSections(text);
      
      return { document };
    } catch (error) {
      console.error('Error processing file:', error);
      return {
        document: {},
        error: `Error processing file: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }
  
  /**
   * Get the file type from the file name or type
   * @param file File object
   * @returns File type string
   */
  private static getFileType(file: File): string {
    const fileName = file.name.toLowerCase();
    
    if (fileName.endsWith('.pdf')) return 'pdf';
    if (fileName.endsWith('.docx')) return 'docx';
    if (fileName.endsWith('.doc')) return 'doc';
    if (fileName.endsWith('.txt')) return 'txt';
    
    // Fallback to MIME type check
    const mimeType = file.type.toLowerCase();
    
    if (mimeType === 'application/pdf') return 'pdf';
    if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') return 'docx';
    if (mimeType === 'application/msword') return 'doc';
    if (mimeType === 'text/plain') return 'txt';
    
    return 'unknown';
  }
  
  /**
   * Process PDF files
   * @param file PDF file to process
   * @returns Extracted text content
   */
  private static async processPdf(file: File): Promise<string> {
    const formData = new FormData();
    formData.append('file', file);
    
    const response = await fetch('/api/parse-pdf', {
      method: 'POST',
      body: formData
    });
    
    if (!response.ok) {
      throw new Error('Failed to parse PDF');
    }
    
    const data = await response.json();
    return data.text;
  }
  
  /**
   * Process DOCX files
   * @param file DOCX file to process
   * @returns Extracted text content
   */
  private static async processDocx(file: File): Promise<string> {
    const formData = new FormData();
    formData.append('file', file);
    
    const response = await fetch('/api/parse-docx', {
      method: 'POST',
      body: formData
    });
    
    if (!response.ok) {
      throw new Error('Failed to parse DOCX');
    }
    
    const data = await response.json();
    return data.text;
  }
  
  /**
   * Process DOC files (legacy Word format)
   * @returns Extracted text content
   */
  private static async processDoc(): Promise<string> {
    // For now, we'll return an error for DOC files
    throw new Error('Legacy DOC format is not supported. Please convert to DOCX and try again.');
  }
  
  /**
   * Process plain text files
   * @param file Text file to process
   * @returns Extracted text content
   */
  private static async processTxt(file: File): Promise<string> {
    return await file.text();
  }
  
  /**
   * Extract RFP sections from document text
   * @param text Full document text
   * @returns RFP document with extracted sections
   */
  private static extractSections(text: string): RFPDocument {
    const document: RFPDocument = {};
    
    // Define section patterns to look for
    const sectionPatterns = [
      { name: 'introduction', pattern: /\b(?:introduction|1\.0\s+introduction|1\s+introduction|i\.\s+introduction)\b/i },
      { name: 'sow', pattern: /\b(?:statement\s+of\s+work|scope\s+of\s+work|sow|2\.0\s+sow|2\s+sow|ii\.\s+sow)\b/i },
      { name: 'proposalSubmission', pattern: /\b(?:proposal\s+submission|submission\s+instructions|submission\s+requirements)\b/i },
      { name: 'evaluationCriteria', pattern: /\b(?:evaluation\s+criteria|evaluation\s+factors|proposal\s+evaluation)\b/i }
    ];
    
    // Split text into lines for analysis
    const lines = text.split(/\r?\n/);
    
    // Initial section detection
    const sectionMarkers: Array<{ name: string; startIndex: number; endIndex?: number }> = [];
    
    // First pass: identify section headings
    lines.forEach((line, index) => {
      for (const { name, pattern } of sectionPatterns) {
        if (pattern.test(line)) {
          sectionMarkers.push({ name, startIndex: index });
          break;
        }
      }
    });
    
    // Second pass: establish section boundaries
    sectionMarkers.forEach((section, index) => {
      if (index < sectionMarkers.length - 1) {
        section.endIndex = sectionMarkers[index + 1].startIndex;
      } else {
        section.endIndex = lines.length;
      }
    });
    
    // Extract section content
    sectionMarkers.forEach(section => {
      if (section.endIndex !== undefined) {
        const sectionText = lines.slice(section.startIndex, section.endIndex).join('\n').trim();
        document[section.name as keyof RFPDocument] = { content: sectionText } as RFPSection;
      }
    });
    
    return document;
  }
}
</file>

<file path="src/app/lib/rfpAnalyzer.ts">
import { RFPDocument, AnalysisResults, Recommendation, ExecutiveSummary, SectionAnalysisResult } from '@/app/types';
import { IntroductionAnalyzer } from './analyzers/introductionAnalyzer';
import { RiskAssessmentAnalyzer } from './analyzers/riskAssessmentAnalyzer';
import { ManagementApproachAnalyzer } from './analyzers/managementApproachAnalyzer';
import { ContractDataAnalyzer } from './analyzers/contractDataAnalyzer';
import { SupplyChainRiskAnalyzer } from './analyzers/supplyChainRiskAnalyzer';
import { PerformanceAnalyzer } from './analyzers/periodOfPerformanceAnalyzer';
import { KeyPersonnelAnalyzer } from './analyzers/keyPersonnelAnalyzer';
import { CybersecurityAnalyzer } from './analyzers/cybersecurityAnalyzer';
import { SubcontractingPlanAnalyzer } from './analyzers/subcontractingPlanAnalyzer';
import { EnvironmentalAnalyzer } from './analyzers/environmentalAnalyzer';
import { ContractTermsAnalyzer } from './analyzers/contractTermsAnalyzer';
import { EvaluationCriteriaAnalyzer } from './analyzers/evaluationCriteriaAnalyzer';
import { ProposalSubmissionAnalyzer } from './analyzers/proposalSubmissionAnalyzer';
import { SOWAnalyzer } from './analyzers/sowAnalyzer';
import { PastPerformanceAnalyzer } from './analyzers/pastPerformanceAnalyzer';
import { CertificationsAnalyzer } from './analyzers/certificationsAnalyzer';
import { TechnicalApproachAnalyzer } from './analyzers/technicalApproachAnalyzer';
import { PriceCostProposalAnalyzer } from './analyzers/priceCostProposalAnalyzer';

export class RFPAnalyzer {
  private sections: Record<string, any>;

  constructor() {
    this.sections = {
      introduction: new IntroductionAnalyzer(),
      sow: new SOWAnalyzer(),
      proposalSubmission: new ProposalSubmissionAnalyzer(),
      evaluationCriteria: new EvaluationCriteriaAnalyzer(),
      contractTerms: new ContractTermsAnalyzer(),
      priceCostProposal: new PriceCostProposalAnalyzer(),
      periodOfPerformance: new PerformanceAnalyzer(),
      keyPersonnel: new KeyPersonnelAnalyzer(),
      pastPerformance: new PastPerformanceAnalyzer(),
      subcontractingPlan: new SubcontractingPlanAnalyzer(),
      environmentalConsiderations: new EnvironmentalAnalyzer(),
      cybersecurityPlan: new CybersecurityAnalyzer(),
      supplyChainRisk: new SupplyChainRiskAnalyzer(),
      contractDataRequirements: new ContractDataAnalyzer(),
      certificationsRepresentations: new CertificationsAnalyzer(),
      technicalApproach: new TechnicalApproachAnalyzer(),
      managementApproach: new ManagementApproachAnalyzer(),
      riskAssessment: new RiskAssessmentAnalyzer()
    };
  }

  analyzeRFP(rfpDocument: RFPDocument): AnalysisResults {
    const sectionResults: Record<string, SectionAnalysisResult | { status: string; message: string }> = {};
    
    for (const [sectionName, analyzer] of Object.entries(this.sections)) {
      if (rfpDocument[sectionName as keyof RFPDocument]?.content) {
        sectionResults[sectionName] = analyzer.analyze(rfpDocument[sectionName as keyof RFPDocument]?.content);
      } else {
        sectionResults[sectionName] = {
          status: 'Not Found',
          message: `${sectionName} section not found in RFP document`
        };
      }
    }
    
    const executiveSummary = this.generateExecutiveSummary(sectionResults);
    const recommendations = this.generateRecommendations(sectionResults);
    
    return {
      executiveSummary,
      recommendations,
      ...sectionResults,
    };
  }
  
  private generateExecutiveSummary(results: Record<string, SectionAnalysisResult | { status: string; message: string }>): ExecutiveSummary {
    const sectionScores: Record<string, number> = {};
    let overallScore = 0;
    let sectionsCount = 0;
    const foundSections: string[] = [];
    const missingSections: string[] = [];
    let weakSectionCount = 0;
    let strongSectionCount = 0;
    
    for (const [sectionName, analysis] of Object.entries(results)) {
      if ('status' in analysis && analysis.status === 'Not Found') {
        missingSections.push(sectionName);
      } else if ('evaluationScore' in analysis) {
        const sectionAnalysis = analysis as SectionAnalysisResult;
        foundSections.push(sectionName);
        sectionScores[sectionName] = sectionAnalysis.evaluationScore;
        overallScore += sectionAnalysis.evaluationScore;
        sectionsCount++;
        if (sectionAnalysis.evaluationScore < 3) weakSectionCount++;
        if (sectionAnalysis.evaluationScore >= 4) strongSectionCount++;
      }
    }

    const finalScore = sectionsCount > 0 ? parseFloat((overallScore / sectionsCount).toFixed(1)) : 0;

    let summary = `The RFP analysis resulted in an overall score of ${finalScore} out of 5. `;
    const keyFindings: string[] = [];

    if (strongSectionCount > sectionsCount / 2) {
      summary += 'The document demonstrates strong overall quality with several well-defined sections. ';
      keyFindings.push(`High overall quality with ${strongSectionCount} strong section(s).`);
    } else if (weakSectionCount > sectionsCount / 2) {
      summary += 'Significant weaknesses were identified, requiring attention in key areas. ';
      keyFindings.push(`Significant weaknesses detected in ${weakSectionCount} section(s).`);
    } else {
      summary += 'The document shows moderate quality with a mix of strengths and areas for improvement. ';
      keyFindings.push('Moderate overall quality with potential for improvement.');
    }

    const topSections = this.getTopSections(sectionScores, 2).map(s => s.section);
    if (topSections.length > 0) {
      keyFindings.push(`Strongest sections: ${topSections.join(', ')}.`);
    }

    const bottomSections = this.getBottomSections(sectionScores, 2).map(s => s.section);
    if (bottomSections.length > 0) {
      keyFindings.push(`Weakest sections needing attention: ${bottomSections.join(', ')}.`);
    }

    if (missingSections.length > 0) {
      summary += `${missingSections.length} section(s) were missing or could not be identified.`;
      keyFindings.push(`Missing sections: ${missingSections.join(', ')}.`);
    }
    
    return {
      overallScore: finalScore,
      summary: summary.trim(),
      keyFindings,
    };
  }
  
  private getTopSections(sectionScores: Record<string, number>, count: number) {
    return Object.entries(sectionScores)
      .sort((a, b) => b[1] - a[1])
      .slice(0, count)
      .map(([section, score]) => ({ section, score }));
  }
  
  private getBottomSections(sectionScores: Record<string, number>, count: number) {
    return Object.entries(sectionScores)
      .sort((a, b) => a[1] - b[1])
      .slice(0, count)
      .map(([section, score]) => ({ section, score }));
  }
  
  private generateRecommendations(results: Record<string, SectionAnalysisResult | { status: string; message: string }>): Recommendation[] {
    const allRecommendations: Recommendation[] = [];
    
    // Add section-specific recommendations
    for (const [sectionName, analysis] of Object.entries(results)) {
      // Check if it's a valid SectionAnalysisResult and has recommendations
      if ('recommendations' in analysis && Array.isArray(analysis.recommendations)) {
        const sectionAnalysis = analysis as SectionAnalysisResult;
        // Assuming section recommendations are now structured correctly as per SectionAnalysisResult
        // If they are just strings, they need conversion
        // For now, let's assume they are Recommendation-like objects or need structuring
        sectionAnalysis.recommendations.forEach((rec: any) => { 
          // Adapt this based on the actual structure of recommendations in analyzers
          allRecommendations.push({
            priority: rec.priority || 'medium', // Default priority if not specified
            section: sectionName,
            recommendation: rec.description || rec.recommendation || rec // Handle different possible shapes
          });
        });
      }
    }
    
    // Add process improvement recommendations
    const processImprovements: Recommendation[] = [
      {
        priority: 'medium',
        section: 'Overall Process',
        recommendation: 'Implement a standardized RFP template that includes all required sections with clear guidelines for each.'
      },
      {
        priority: 'medium',
        section: 'Overall Process',
        recommendation: 'Ensure consistency of requirements, terminology, and evaluation metrics across all RFP sections.'
      },
      {
        priority: 'medium',
        section: 'Overall Process',
        recommendation: 'Use automated tools to check for completeness, clarity, and compliance with organizational standards.'
      }
    ];
    
    allRecommendations.push(...processImprovements);
    
    return allRecommendations;
  }
}
</file>

<file path="src/app/lib/stores/analysisStore.ts">
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { AnalysisResults } from '@/app/types';

interface AnalysisStore {
  analysisResults: Record<string, AnalysisResults>;
  currentAnalysisId: string | null;
  setAnalysisResults: (id: string, results: AnalysisResults) => void;
  setCurrentAnalysisId: (id: string) => void;
  getAnalysisById: (id: string) => AnalysisResults | null;
}

export const useAnalysisStore = create<AnalysisStore>()(
  persist(
    (set, get) => ({
      analysisResults: {},
      currentAnalysisId: null,
      
      setAnalysisResults: (id, results) => set((state) => ({
        analysisResults: {
          ...state.analysisResults,
          [id]: results
        }
      })),
      
      setCurrentAnalysisId: (id) => set({ currentAnalysisId: id }),
      
      getAnalysisById: (id) => {
        const { analysisResults } = get();
        return analysisResults[id] || null;
      }
    }),
    {
      name: 'rfp-analysis-storage',
      partialize: (state) => ({ analysisResults: state.analysisResults })
    }
  )
);
</file>

<file path="src/app/page.tsx">
import UploadForm from './components/forms/UploadForm';

export default function Home() {
  return (
    <main className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">RFP Analysis Tool</h1>
      <p className="mb-8 text-lg">
        Upload an RFP document to analyze 18 key sections, evaluate compliance, 
        and receive recommendations for improvement.
      </p>
      
      <UploadForm />
      
      <div className="mt-12">
        <h2 className="text-2xl font-semibold mb-4">Key Features</h2>
        <ul className="list-disc pl-5 space-y-2">
          <li>Comprehensive analysis of 18 RFP sections</li>
          <li>Extraction of key information and requirements</li>
          <li>Standardized evaluation against industry best practices</li>
          <li>Prioritized recommendations for improvement</li>
          <li>Executive summary with strengths and weaknesses</li>
        </ul>
      </div>
    </main>
  );
}
</file>

<file path="src/app/results/[id]/page.tsx">
'use client';

import { useEffect, useState } from 'react';
import { notFound, useRouter } from 'next/navigation';
import ExecutiveSummary from '@/app/components/results/ExecutiveSummary';
import SectionAnalysis from '@/app/components/dashboard/SectionAnalysis';
import RecommendationsList from '@/app/components/dashboard/RecommendationsList';
import { useAnalysisStore } from '@/app/lib/stores/analysisStore';
import { AnalysisResults } from '@/app/types';

export default function ResultsPage({ params }: { params: { id: string } }) {
  const { id } = params;
  const router = useRouter();
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // Get analysis from store
  const getAnalysisById = useAnalysisStore((state) => state.getAnalysisById);
  const setCurrentAnalysisId = useAnalysisStore((state) => state.setCurrentAnalysisId);
  const [results, setResults] = useState<AnalysisResults | null>(null);
  
  useEffect(() => {
    // First, check if we have this analysis in the store
    const storedResults = getAnalysisById(id);
    
    if (storedResults) {
      setResults(storedResults);
      setCurrentAnalysisId(id);
      setLoading(false);
    } else {
      // If not in store, fetch from API
      const fetchResults = async () => {
        try {
          const response = await fetch(`/api/analysis/${id}`);
          
          if (!response.ok) {
            if (response.status === 404) {
              return notFound();
            }
            throw new Error('Failed to fetch analysis results');
          }
          
          const data = await response.json();
          setResults(data.results);
          setCurrentAnalysisId(id);
        } catch (err) {
          setError(err instanceof Error ? err.message : 'An unknown error occurred');
        } finally {
          setLoading(false);
        }
      };
      
      fetchResults();
    }
  }, [id, getAnalysisById, setCurrentAnalysisId]);
  
  if (loading) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="flex items-center justify-center h-64">
          <div className="text-center">
            <div className="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-600 mb-4"></div>
            <p className="text-gray-600">Loading analysis results...</p>
          </div>
        </div>
      </div>
    );
  }
  
  if (error) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="bg-red-50 p-4 rounded-md">
          <h2 className="text-xl font-semibold text-red-700 mb-2">Error</h2>
          <p className="text-red-600">{error}</p>
          <button
            onClick={() => router.push('/')}
            className="mt-4 px-4 py-2 bg-blue-600 text-white rounded-md"
          >
            Return to Home
          </button>
        </div>
      </div>
    );
  }
  
  if (!results) {
    return notFound();
  }
  
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">RFP Analysis Results</h1>
      
      <ExecutiveSummary summary={results.executiveSummary} />
      
      <div className="mt-8 grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-2">
          <h2 className="text-2xl font-semibold mb-4">Section Analysis</h2>
          <SectionAnalysis analysisResults={results} />
        </div>
        
        <div>
          <h2 className="text-2xl font-semibold mb-4">Recommendations</h2>
          <RecommendationsList recommendations={results.recommendations} />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/types.ts">
export interface RFPSection {
  content: string;
}

export interface RFPDocument {
  introduction?: RFPSection;
  sow?: RFPSection;
  proposalSubmission?: RFPSection;
  evaluationCriteria?: RFPSection;
  [key: string]: RFPSection | undefined;
}

export interface EvaluationResult {
  criterion: string;
  score: number;
  maxScore: number;
  comments: string;
}

export interface SectionAnalysisResult {
  sectionName: string;
  content: string;
  evaluationScore: number;
  recommendations: Array<{
    priority: 'high' | 'medium' | 'low';
    title: string;
    description: string;
  }>;
  extractedInformation: Record<string, string>;
  evaluationResults: EvaluationResult[];
}

export interface ExecutiveSummary {
  overallScore: number;
  summary: string;
  keyFindings: string[];
}

export interface Recommendation {
  priority: 'high' | 'medium' | 'low';
  section: string;
  recommendation: string;
}

export interface AnalysisResults {
  executiveSummary: ExecutiveSummary;
  recommendations: Recommendation[];
  [key: string]: SectionAnalysisResult | ExecutiveSummary | Recommendation[] | { status: string; message: string };
}
</file>

<file path="src/app/types/index.ts">
// Remove the faulty import if it exists:
// import { SectionAnalysisResult as ImportedSectionAnalysisResult, ... } from './interfaces';

// Re-exporting the interfaces for easier access
export type { SectionAnalysisResult as ImportedSectionAnalysisResult };
export type { ExecutiveSummary as ImportedExecutiveSummary };
export type { Recommendation as ImportedRecommendation };

// Define basic types if not already in interfaces.ts
export interface RFPSection {
  content: string;
}

export interface RFPDocument {
  introduction?: RFPSection;
  sow?: RFPSection;
  proposalSubmission?: RFPSection;
  evaluationCriteria?: RFPSection;
  contractTerms?: RFPSection;
  priceCostProposal?: RFPSection;
  periodOfPerformance?: RFPSection;
  keyPersonnel?: RFPSection;
  pastPerformance?: RFPSection;
  subcontractingPlan?: RFPSection;
  environmentalConsiderations?: RFPSection;
  cybersecurityPlan?: RFPSection;
  supplyChainRisk?: RFPSection;
  contractDataRequirements?: RFPSection;
  certificationsRepresentations?: RFPSection;
  technicalApproach?: RFPSection;
  managementApproach?: RFPSection;
  riskAssessment?: RFPSection;
  // Allow any string key for flexibility, mapping to RFPSection or undefined
  [key: string]: RFPSection | undefined; 
}

// Main AnalysisResults type combining specific fields and section results
export type AnalysisResults = {
  executiveSummary: ExecutiveSummary;
  recommendations: Recommendation[];
} & {
  // Index signature for individual section analysis results or not found status
  [sectionName: string]: SectionAnalysisResult | { status: string; message: string };
};

export interface EvaluationResult {
  criterion: string;
  score: number;
  maxScore: number;
  comments: string;
}

// Updated Recommendation interface
export interface Recommendation {
  priority: 'high' | 'medium' | 'low';
  section: string;
  recommendation: string;
}

export interface SectionAnalysisResult {
  sectionName: string;
  extractedInformation: Record<string, string>;
  evaluationResults: EvaluationResult[];
  evaluationScore: number;
  // Assuming recommendations from analyzers are simple strings for now
  // If they need to be full Recommendation objects, the analyzers need updating
  recommendations: string[]; 
}

// Corrected ExecutiveSummary interface (should match usage)
export interface ExecutiveSummary {
  overallScore: number;
  summary: string;
  keyFindings: string[];
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "forceConsistentCasingInFileNames": true,
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

</files>
